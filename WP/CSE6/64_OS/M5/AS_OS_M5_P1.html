<!DOCTYPE html>
<html lang="en">
<head>
<!--Infolinks script -->
<script type="text/javascript">
var infolinks_pid = 3211351;
var infolinks_wsid = 0;
</script>
<script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146647335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146647335-1');
</script>
<title> ANSWER SCRIPT - OPERATING SYSTEMS - Module 5 - Answer - Question Paper Solved - 18cs43 - 17cs64</title>
<meta name="google-site-verification" content="google0186c8ef8f3bf22a.html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- indexing -->
<meta name="description" content="OPERATING SYSTEMS - ANSWER SCRIPT, Solved OS Paper , Module 5 ">

<meta name="keywords" content="MODULE 5,OPERATING SYSTEMS,18CS43,17CS64,6th sem, 4 sem, 6 sem, 4th sem, 18 scheme, 17 scheme, 
answer script,solved paper, cbcs, vtu 17 scheme, vtu, 18 scheme, OS Notes, OS solved, Previous paper solved, paper solved, os paper">

<link rel="icon" type="image/ico" href="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" />


<link rel="stylesheet" href="https://hemanthrajhemu.github.io/FutureVisionBIE/style.css"/>			
<link rel="stylesheet" type="text/css" href="https://hemanthrajhemu.github.io/FutureVisionBIE/prints.css" media="print" />
		

<script src="https://hemanthrajhemu.github.io/FutureVisionBIE/script.js"> </script>
</head>
<body oncopy="return false" onselectstart="return false">
<div id="main">
<!-- HEADER NAME WITH LOGO  -->
<header>
   <h1 class="FVBIE"><a href="https://hemanthrajhemu.github.io"><img src="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" alt="Future Vision BIE" style="float:left ;width:170px;height:140px;"></a>
   Future Vision BIE</h1><br/> <h1 class="FVBIE1">ONE STOP FOR ALL STUDY MATERIALS & LAB PROGRAMS</h1><br/>
   
</header>
<!-- TOP NAVIGATION TOOLS -->
<div class="topnav">
  
  <a class="openbtn" onclick="openNav()" style="font-family:courier; font-size:25px; text-align:center;">
	<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/menu.png" alt="E" style="width:38px;height:38px;"/>
	MENU
  </a>
  <a href="https://bit.ly/FVBIESHARE" style="float:right;" >
				<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/web.png" alt="Whatsapp Share" style="float:right; width:80px;height:40px;"/>
  </a>
  <a href="https://t.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ" style="float:right;">Join Telegram, to get Instant Updates</a>

</div>
<!--  NAVIGATION TOOLS -->
<div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">
		<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/cancel-64.png" alt="X" style="width:64px;height:64px;"/>
	</a><br/>
  
<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/disclaimer.html">Disclaimer</a>
    
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/JavaHtml/java.html">4th sem <br/>Java-DAA Programs</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE">5th sem CSE<br/>Text Book<br/>Programs<br/></a>
    <a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/61_CNSCL/"> 17CS61 - CRYPTOGRAPHY, NETWORK SECURITY AND CYBER LAW </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/62_CGV/"> 17CS62 - COMPUTER GRAPHICS AND VISUALIZATION </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/63_SSCD/"> 17CS63 - SYSTEM SOFTWARE AND COMPILER DESIGN </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/64_OS/"> 17CS64 - OPERATING SYSTEMS </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/PE/"> 17CS65* -  Professional Elective</a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/OE/"> 17CS66* - Open Elective </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L67_SSOS/"> 17CSL67 - SYSTEM SOFTWARE AND OPERATING SYSTEM LABORATORY </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L68_CGL/"> 17CSL68 - COMPUTER GRAPHICS LABORATORY WITH MINI PROJECT </a>
		
	<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
	
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/contact.html">CONTACT</a>
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/">HOME</a><br/><br/><br/><br/>
</div>
<!-- CENTER PATH FOR INFO  -->
<article>



	<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	  <strong>NOTE!</strong>
	  Click on MENU to Browse between Subjects...
	</div>


<hr/>
<div class="ads" id="ads" align="center">
Advertisement
<!-- Infolinks In-Article-Ad -->
<input type="hidden" name="IL_IN_ARTICLE">
</div>
<hr/>



 <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 5
 </h1><h1>Solved Previous Year Question Paper
 </h1><h1>CBCS SCHEME</h1>
 
<br/>
</p></div>




<div class="desp">

<p>
<h1>OPERATING SYSTEMS</h1><h1>
[As per Choice Based Credit System (CBCS) scheme]</h1><h1>
(Effective from the academic year 2017 - 2018)</h1><h1>
SEMESTER - IV/VI</h1><h1>
Subject Code 18CS43/17CS64 </h1><h1>IA Marks 40</h1><h1>
Number of Lecture Hours/Week 3</h1><h1> Exam Marks 60 </h1>
</p>

</div>
<br/>



<hr/>
<div class="ads" id="ads" align="center">
Advertisement
<!-- Infolinks In-Article-Ad -->
<input type="hidden" name="IL_IN_ARTICLE">
</div>
<hr/>



<!-- CONTENT AFTER LINK  -->

 <div class="desp" style="text-align: justify;"> 
 <h1>
 These Questions are being framed for helping the students in the "FINAL Exams" Only 
 (Remember for Internals the Question Paper is set by your respective teachers). 
 Questions may be repeated, just to show students how VTU can frame Questions.
<br/></h1>
<p style="color:green; font-family:courier; font-size:25px; text-align:right;">
-	ADMIN</p>

</h1>
</div>
<br/>



<!-- trying now--->
   <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 5</h1>
 

</p></div>
<br/>
<br/>


 <div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
 CLICK ON THE QUESTIONS TO VIEW ANSWER<br/>
</div>
 <br/>
<!-- Answer Script -->

			<div class="ansCover">
			<div class="QAS"><a onclick="show('ANScript1')">Question 1<h1>Explain the various Disk Scheduling algorithms with example. (08 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript1">
			
			<h2>Answer:</h2>
			
			<p><h3>
	<strong><h2>1.1 Disk Scheduling Algorithm (Introduction):</h2></strong>
</h3></p>
<p><h3>
	One of the responsibilities of the operating system is to use the hardware
	efficiently. For the disk drives, meeting this responsibility entails
	having fast access time and large disk bandwidth.
</h3></p>
<p><h3>
	The access time has two major components.
</h3></p>
<p><h3>
	<strong><h2>The seek time</h2></strong>
	is the time for the disk arm to move the heads to the cylinder containing
	the desired sector.
</h3></p>
<p><h3>
	<strong><h2>The rotational latency</h2></strong>
	is the additional time for the disk to rotate the desired sector to the
	disk head.
</h3></p>
<p><h3>
	The <strong><h2>disk bandwidth</h2></strong> is the total number of bytes
	transferred, divided by the total time between the first request for
	service and the completion of the last transfer. We can improve both the
	access time and the bandwidth by scheduling the servicing of disk I/O
	requests in a good order
</h3></p>
<p><h3>
	Whenever a process needs I/O to or from the disk, it issues a system call
	to the operating system. The request specifies several pieces of
	information:
</h3></p>
<p><h3>
	i. Whether this operation is input or output
</h3></p>
<p><h3>
	ii. What the disk address for the transfer is
</h3></p>
<p><h3>
	iii. What the memory address for the transfer is
</h3></p>
<p><h3>
	iv. What the number of sectors to be transferred is
</h3></p>
<p><h3>
	If the desired disk drive and controller are available, the request can be
	serviced immediately. If the drive or controller is busy, any new requests
	for service will be placed in the queue of pending requests for that drive.
</h3></p>
<p><h3>
	The various Disk Scheduling algorithms are as follows:
</h3></p>
<p><h3>
	i. FCFS Scheduling
</h3></p>
<p><h3>
	ii. SSTF Scheduling
</h3></p>
<p><h3>
	iii. SCAN Scheduling
</h3></p>
<p><h3>
	iv. C-SCAN Scheduling
</h3></p>
<p><h3>
	v. LOOK Scheduling
</h3></p>
<p><h3>
	vi. Selection of a Disk-Scheduling Algorithm
</h3></p>
<p><h3>
	<strong><h2>1.2 FCFS Scheduling:</h2></strong>
</h3></p>
<p><h3>
	The simplest form of disk scheduling is, of course, the first-come,
	first-served (FCFS) algorithm. This algorithm is intrinsically fair, but it
	generally does not provide the fastest service. Consider, for example, a
	disk queue with requests for I/O to blocks on cylinders
</h3></p>
<p><h3>
	<strong><h2>98, 183, 37,122, 14, 124, 65, 67</h2></strong>
</h3></p>
<p><h3>
	in that order. If the disk head is initially at cylinder 53, it will first
	move from 53 to 98, then to 183, 37, 122, 14, 124/65, and finally to 67,
	for a total head movement of 640 cylinders. This schedule is diagrammed in
	Figure 1.1.<strong><h2></h2></strong>
</h3></p>
<p align="center">

<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/1.1.jpg" 
alt="Program Output" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 1.1 FCFS disk scheduling
</h3></p>
<p><h3>
	The wild swing from 122 to 14 and then back to 124 illustrates the problem
	with this schedule. If the requests for cylinders 37 and 14 could be
	serviced together, before or after the requests at 122 and 124, the total
	head movement could be decreased substantially, and performance could be
	thereby improved.
</h3></p>
<p><h3>
	<strong><h2>1.3 SSTF Scheduling</h2></strong>
</h3></p>
<p><h3>
	It seems reasonable to service all the requests close to the current head
	position before moving the head far away to service other requests. This
assumption is the basis for the	<strong><h2>shortest-seek-time-first (SSTF) algorithm</h2></strong>.
</h3></p>
<p><h3>
	The <strong><h2>SSTF algorithm</h2></strong> selects the request with the minimum
	seek time from the current head position. Since seek time increases with
	the number of cylinders traversed by the head, SSTF chooses the pending
	request closest to the current head position.
</h3></p>
<p><h3>
	For our <strong><h2>example</h2></strong> request queue, the closest request to the
	initial head position (53) is at cylinder 65. Once we are at cylinder 65,
	the next closest request is at cylinder 67. From there, the request at
	cylinder 37 is closer than the one at 98, so 37 is served next. Continuing,
	we service the request at cylinder 14, then 98,122, 124, and finally 183
	(Figure 1.2).
</h3></p>
<p><h3>
	This <strong><h2>scheduling </h2></strong>method results in a total head movement of
	only 236 cylinders-little more than one-third of the distance needed for
FCFS scheduling of this request queue. This algorithm gives a	<strong><h2>substantial improvement in performance</h2></strong>.
</h3></p>
<p><h3>
	<strong><h2>SSTF scheduling</h2></strong>
is essentially a form of	<strong><h2>shortest-job-first (SJF) scheduling</h2></strong>; and like SJF
	scheduling, it may cause starvation of some requests. Remember that
	requests may arrive at any time. Suppose that we have two requests in the
	queue, for cylinders 14 and 186, and while servicing the request from 14, a
	new request near 14 arrives.
</h3></p>
<p align="center">

<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/1.2.jpg" 
alt="Program Output" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 1.2 SSTF disk scheduling.
</h3></p>
<p><h3>
	This new request will be serviced next, making the request at 186 wait.
	While this request is being serviced, another request close to 14 could
	arrive. In theory, a continual stream of requests near one another could
	arrive, causing the request for cylinder 186 to wait indefinitely. This
	scenario becomes increasingly likely if the pending-request queue grows
	long.
</h3></p>
<p><h3>
	<strong><h2>1.4 SCAN Scheduling:</h2></strong>
</h3></p>
<p><h3>
	In the <strong><h2>SCAN algorithm</h2></strong>, the disk arm starts at one end of
	the disk and moves toward the other end, servicing requests as it reaches
	each cylinder, until it gets to the other end of the disk. At the other
	end, the direction of head movement is reversed, and servicing continues.
	The head continuously scans back and forth across the disk.
</h3></p>
<p><h3>
	The <strong><h2>SCAN algorithm</h2></strong> is sometimes called the elevator
	algorithm, since the disk arm behaves just like an elevator in a building,
	first servicing all the requests going up and then reversing to service
	requests the other way.
</h3></p>
<p><h3>
Let's return to our <strong><h2>example</h2></strong> to illustrate. Before<strong><h2>applying SCAN</h2></strong> to schedule the requests on cylinders	<strong><h2>98,183, 37,122,14, 124, 65, and 67</h2></strong>, we need to know the
	direction of head movement in addition to the head's current position (53).
	If the disk arm is moving toward 0, the head will service 37 and then 14.
	At cylinder 0, the arm will reverse and will move toward the other end of
	the disk, servicing the requests at 65, 67, 98, 122, 124, and 183 (Figure
	1.3).
</h3></p>
<p align="center">

<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/1.3.jpg" 
alt="Program Output" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 1.3 SCAN disk scheduling
</h3></p>
<p><h3>
	If a request arrives in the queue just in front of the head, it will be
	serviced almost immediately; a request arriving just behind the head will
	have to wait until the arm moves to the end of the disk, reverses
	direction, and comes back.
</h3></p>
<p><h3>
	Assuming a <strong><h2>uniform distribution of requests</h2></strong> for cylinders,
	consider the density of requests when the head reaches one end and reverses
	direction. At this point, relatively few requests are immediately in front
	of the head, since these cylinders have recently been serviced. The
	heaviest density of requests is at the other end of the disk
</h3></p>
<p><h3>
	<strong><h2>1.5 C-SCAN Scheduling:</h2></strong>
</h3></p>
<p><h3>
	<strong><h2>Circular SCAN (C-SCAN) scheduling</h2></strong>
is a variant of SCAN designed to provide a more uniform wait time.	<strong><h2>Like SCAN, C-SCAN</h2></strong> moves the head from one end of the disk
	to the other, servicing requests along the way. When the head reaches the
	other end, however, it immediately returns to the beginning of the disk,
	without servicing any requests on the return trip (Figure 1.4).
</h3></p>
<p align="center">

<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/1.4.jpg" 
alt="Program Output" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 1.4 C-SCAN disk scheduling.
</h3></p>
<p><h3>
	The <strong><h2>C-SCAN scheduling algorithm</h2></strong> essentially treats the
	cylinders as a circular list that wraps around from the final cylinder to
	the first one.
</h3></p>
<p><h3>
	<strong><h2>1.6 LOOK Scheduling:</h2></strong>
</h3></p>
<p><h3>
	As we described them, both <strong><h2>SCAN and C-SCAK</h2></strong> move the disk
	arm across the full width of the disk. In practice, neither algorithm is
	often implemented this way. More commonly, the arm goes only as far as the
	final request in each direction.
</h3></p>
<p align="center">

<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/1.5.jpg" 
alt="Program Output" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 1.5 C-LOOK disk scheduling.
</h3></p>
<p><h3>
	Then, it reverses direction immediately, without going all the way to the
	end of the disk. Versions of <strong><h2>SCAN and C-SCAN</h2></strong> that follow
	this pattern are called <strong><h2>LOOK and C-LOOK scheduling</h2></strong>,
	because they look for a request before continuing to move in a given
	direction (Figure 1.5).
</h3></p>
<p><h3>
	<strong><h2>1.7 Selection of a Disk-Scheduling Algorithm:</h2></strong>
</h3></p>
<p><h3>
	SSTF is commonly used and it increases performance over FCFS. SCAN and
	C-SCAN algorithm is better for a heavy load on disk. SCAN and C-SCAN have
	less starvation problem.
</h3></p>
<p><h3>
	Disk scheduling algorithm should be written as a separate module of the
	operating system. SSTF or Look is a reasonable choice for a default
	algorithm.
</h3></p>
<p><h3>
	SSTF is commonly used algorithms has it has a less seek time when compared
	with other algorithms. SCAN and C-SCAN perform better for systems with a
	heavy load on the disk, (ie. more read and write operations from disk).
</h3></p>
<p><h3>
	Selection of disk scheduling algorithm is influenced by the file allocation
	method, if contiguous file allocation is chosen, then FCFS is best
	suitable, because the files are stored in contiguous blacks and there will
	be limited head movements required. A linked or indexed file, in contrast,
	may include blocks that are widely scattered on the disk, resulting in
	greater head movement.
</h3></p>
<p><h3>
	The location of directories and index blocks is also important. Since every
	file must be opened to be used, and opening a file requires searching the
	directory structure, the directories will be accessed frequently. Suppose
	that a directory entry is on the first cylinder and a file's data are on
	the final cylinder. The disk head has to move the entire width of the disk.
	If the directory entry were on the middle cylinder, the head would have to
	move, at most, one-half the width. Caching the directories and index blocks
	in main memory can also help to reduce the disk-arm movement, particularly
	for read requests.
</h3></p>
<p><h3>
	Because of these complexities, the disk-scheduling algorithm is very
	important and is written as a separate module of the operating system.
</h3></p>
			
			
			
			
			</div><br/>
			


<hr/>
<div class="ads" id="ads" align="center">
Advertisement
<!-- Infolinks In-Article-Ad -->
<input type="hidden" name="IL_IN_ARTICLE">
</div>
<hr/>



<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript2')">Question 2<h1>Explain access matrix method of system protection. (08 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript2">
			
			<h2>Answer:</h2>
			
			<p><h3>
	Our model of protection can be viewed abstractly as a matrix, called an
	access matrix. The rows of the access matrix represent domains, and the
	columns represent objects. Each entry in the matrix consists of a set of
	access rights. Because the column defines objects explicitly, we can omit
	the object name from the access right. The entry access (i, j) defines the
	set of operations that a process executing in domain D1 can invoke on
	object Oj.
</h3></p>
<p><h3>
	To illustrate these concepts, we consider the access matrix shown in Figure
	2.1. There are four domains and four objects-three files (F1, F2, F3) and
	one laser printer. A process executing in domain D1 can read files F1 and
	F3. A process executing in domain D4 has the same privileges as one
	executing in domain D1; but in addition, it can also write onto files F1
	and F3. Note that the laser printer can be accessed only by a process
	executing in domain D0
</h3></p>
<center>
<table border="10" cellspacing="auto" cellpadding="auto" width="auto">
	<tbody>
		<tr>
			<td width="189" valign="top">
				<p><h3>
					domain object
				</h3></p>
			</td>
			<td width="94" valign="top">
				<p align="center">
					F1
				</h3></p>
			</td>
			<td width="95" valign="top">
				<p align="center">
					F2
				</h3></p>
			</td>
			<td width="104" valign="top">
				<p align="center">
					F3
				</h3></p>
			</td>
			<td width="95" valign="top">
				<p align="center">
					Printer
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="189" valign="top">
				<p align="center">
					D1
				</h3></p>
			</td>
			<td width="94" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="95" valign="top">
			</td>
			<td width="104" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="95" valign="top">
			</td>
		</tr>
		<tr>
			<td width="189" valign="top">
				<p align="center">
					D2
				</h3></p>
			</td>
			<td width="94" valign="top">
			</td>
			<td width="95" valign="top">
			</td>
			<td width="104" valign="top">
			</td>
			<td width="95" valign="top">
				<p align="center">
					Print
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="189" valign="top">
				<p align="center">
					D3
				</h3></p>
			</td>
			<td width="94" valign="top">
			</td>
			<td width="95" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="104" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="95" valign="top">
			</td>
		</tr>
		<tr>
			<td width="189" valign="top">
				<p align="center">
					D4
				</h3></p>
			</td>
			<td width="94" valign="top">
				<p align="center">
					Read
				</h3></p>
				<p align="center">
					Write
				</h3></p>
			</td>
			<td width="95" valign="top">
			</td>
			<td width="104" valign="top">
				<p align="center">
					Read
				</h3></p>
				<p align="center">
					Write
				</h3></p>
			</td>
			<td width="95" valign="top">
			</td>
		</tr>
	</tbody>
</table></center>
<p align="center">
	Fig 1.1 Access Matrix
</h3></p>
<p><h3>
	The access-matrix scheme provides us with the mechanism for specifying a
	variety of policies. The mechanism consists of implementing the access
	matrix and ensuring that the semantic properties we have outlined indeed,
	hold. More specifically, we must ensure that a process executing in domain
	D1, can access only those objects specified in row 1, and then only as
	allowed by the access-matrix entries.
</h3></p>
<p><h3>
	The access matrix can implement policy decisions concerning protection. The
	policy decisions involve which rights should be included in the (i. j)th
	entry. We must also decide the domain in which each process executes. This
	last policy is usually decided by the operating system.
</h3></p>
<p><h3>
	The users normally decide the contents of the access-matrix entries. When a
	user creates a new object Oi, the column Oj is added to the access matrix
	with the appropriate initialization entries, as dictated by the creator.
	The user may decide to enter some rights in some entries in column 1 and
	other rights in other entries, as needed.
</h3></p>
<p><h3>
	The access matrix provides an appropriate mechanism for defining and
	implementing strict control for both the static and dynamic association
	between processes and domains. When we switch a process from one domain to
	another, we are executing an operation (switch) on an object (the domain).
	We can control domain switching by including domains among the objects of
	the access matrix.
</h3></p>
<p><h3>
	Similarly, when we change the content of the access matrix, we are
	performing an operation on an object: the access matrix. Again, we can
	control these changes by including the access matrix itself as an object.
	Actually, since each entry in the access matrix may be modified
	individually, we must consider each entry in the access matrix as an object
	to be protected. Now, we need to consider only the operations possible on
	these new objects (domains and the access matrix) and decide how we want
	processes to be able to execute these operations.
</h3></p>
<p><h3>
	Processes should be able to switch from one domain to another. Domain
	switching from domain Di to domain Dj is allowed if and only if the access
	right switch access(I, j). Thus, in Figure 2.2, a process executing in
	domain D2 can switch to domain D3 or to domain D4. A process in domain D4
	can switch to D1, and one in domain D1 can switch to domain D2.
</h3></p>
<center>
<table border="10" cellspacing="auto" cellpadding="auto" width="auto">
	<tbody>
		<tr>
			<td width="82" valign="top">
				<p><h3>
					object
				</h3></p>
				<p><h3>
					domain
				</h3></p>
			</td>
			<td width="60" valign="top">
				<p align="center">
					F1
				</h3></p>
			</td>
			<td width="53" valign="top">
				<p align="center">
					F2
				</h3></p>
			</td>
			<td width="74" valign="top">
				<p align="center">
					F3
				</h3></p>
			</td>
			<td width="77" valign="top">
				<p align="center">
					Laser
				</h3></p>
				<p align="center">
					printer
				</h3></p>
			</td>
			<td width="71" valign="top">
				<p align="center">
					D1
				</h3></p>
			</td>
			<td width="56" valign="top">
				<p align="center">
					D2
				</h3></p>
			</td>
			<td width="73" valign="top">
				<p align="center">
					D3
				</h3></p>
			</td>
			<td width="73" valign="top">
				<p align="center">
					D4
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="82" valign="top">
				<p align="center">
					D1
				</h3></p>
			</td>
			<td width="60" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="53" valign="top">
			</td>
			<td width="74" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="77" valign="top">
			</td>
			<td width="71" valign="top">
			</td>
			<td width="56" valign="top">
				<p align="center">
					switch
				</h3></p>
			</td>
			<td width="73" valign="top">
			</td>
			<td width="73" valign="top">
			</td>
		</tr>
		<tr>
			<td width="82" valign="top">
				<p align="center">
					D2
				</h3></p>
			</td>
			<td width="60" valign="top">
			</td>
			<td width="53" valign="top">
			</td>
			<td width="74" valign="top">
			</td>
			<td width="77" valign="top">
				<p align="center">
					print
				</h3></p>
			</td>
			<td width="71" valign="top">
			</td>
			<td width="56" valign="top">
			</td>
			<td width="73" valign="top">
				<p align="center">
					Switch
				</h3></p>
			</td>
			<td width="73" valign="top">
				<p align="center">
					Switch
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="82" valign="top">
				<p align="center">
					D3
				</h3></p>
			</td>
			<td width="60" valign="top">
			</td>
			<td width="53" valign="top">
				<p align="center">
					read
				</h3></p>
			</td>
			<td width="74" valign="top">
				<p align="center">
					execute
				</h3></p>
			</td>
			<td width="77" valign="top">
			</td>
			<td width="71" valign="top">
			</td>
			<td width="56" valign="top">
			</td>
			<td width="73" valign="top">
			</td>
			<td width="73" valign="top">
			</td>
		</tr>
		<tr>
			<td width="82" valign="top">
				<p align="center">
					D4
				</h3></p>
			</td>
			<td width="60" valign="top">
				<p align="center">
					Read
				</h3></p>
				<p align="center">
					Write
				</h3></p>
			</td>
			<td width="53" valign="top">
			</td>
			<td width="74" valign="top">
				<p align="center">
					Read
				</h3></p>
				<p align="center">
					Write
				</h3></p>
			</td>
			<td width="77" valign="top">
			</td>
			<td width="71" valign="top">
				<p align="center">
					switch
				</h3></p>
			</td>
			<td width="56" valign="top">
			</td>
			<td width="73" valign="top">
			</td>
			<td width="73" valign="top">
			</td>
		</tr>
	</tbody>
</table>
<p align="center">
	Fig 2.2 Access matrix of Figure 2.1 with domains as objects
</h3></p>
<table border="10" cellspacing="auto" cellpadding="auto">
	<tbody>
		<tr>
			<td width="150" valign="top">
				<p><h3>
					domain object
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F1
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F2
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F3
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D1
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
			</td>
			<td width="150" valign="top">
				<p align="center">
					Write
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D2
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D3
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
			</td>
			<td width="150" valign="top">
			</td>
		</tr>
	</tbody>
</table>
<p align="center">
	(a)
</h3></p>
<table border="10" cellspacing="auto" cellpadding="auto">
	<tbody>
		<tr>
			<td width="150" valign="top">
				<p><h3>
					domain object
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F1
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F2
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					F3
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D1
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
			</td>
			<td width="150" valign="top">
				<p align="center">
					Write
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D2
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p align="center">
					D3
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Execute
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Read
				</h3></p>
			</td>
			<td width="150" valign="top">
			</td>
		</tr>
	</tbody>
</table></center>
<p align="center">
	(b)
</h3></p>
<p align="center">
	Fig 2.3 Access matrix with copy rights
</h3></p>
<p><h3>
	The ability to copy an access right from one domain (or row) of the access
	matrix to another is denoted by an asterisk (*) appended to the access
	right. The copy right allows the copying of the access right only within
	the column (that is, for the object) for which the right is defined. For
	example, in Figure 2.3(a), a process executing in domain D2 can copy the
	read operation into any entry associated with file F2. Hence, the access
	matrix of Figure 2.3(a) can be modified to the access matrix shown in
	Figure 2.3(b).
</h3></p>
<p><h3>
	This scheme has two variants:
</h3></p>
<p><h3>
	i. A right is copied from access (i, l) to access(k, j); it is then removed
	from access (i, j). This action is a transfer of a right, rather than a
	copy.
</h3></p>
<p><h3>
	ii. Propagation of the copy right may be limited. That is, when the right
	R* is copied from access (I, j) to access (k, j), only the right R (not R*)
	is created. A process executing in domain D<sub>k</sub> cannot further copy
	the right R.
</h3></p>
<p><h3>
	A system may select only one of these three copy rights, or it may provide
	all three by identifying them as separate rights: copy, transfer, and
	limited copy.
</h3></p>
			
			
			
			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript3')">Question 3<h1>With a neat diagram explain in detail components of a Linux system. (06
	Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript3">

			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>3.1 Components of a Linux System:</h2></strong>
</h3></p>
<p><h3>
	The Linux system is composed of three main bodies of code, in line with
	most traditional UNIX implementations:
</h3></p>
<p><h3>
	<strong><h2>1. Kernel.</h2></strong>
	The kernel is responsible for maintaining all the important abstractions of
	the operating system, including such things as virtual memory and
	processes.
</h3></p>
<p><h3>
	<strong><h2>2. System libraries.</h2></strong>
	The system libraries define a standard set of functions through which
	applications can interact with the kernel. These functions implement much
	of the operating-system functionality that does not need the full
	privileges of kernel code.
</h3></p>
<p><h3>
	<strong><h2>3. System utilities.</h2></strong>
	The system utilities are programs that perform individual, specialized
	management tasks. Some system utilities may be invoked just once to
	initialize and configure some aspect of the system; others- known as
	daemons in UNIX terminology-may run permanently, handling such tasks as
	responding to incoming network connections, accepting logon requests from
	terminals, and updating log files.
</h3></p>
<p><h3>
	Figure 3.1 illustrates the various components that make up a full Linux
	system. The most important distinction here is between the kernel and
	everything else.
</h3></p>
<p><h3>
	All the kernel code executes in the processor's privileged mode with full
	access to all the physical resources of the computer. Linux refers to this
	privileged mode as <strong><h2>kernel mode</h2></strong>.
</h3></p>
<center>
<table border="10" cellspacing="auto" cellpadding="auto">
	<tbody>
		<tr>
			<td width="163" valign="top">
				<p align="center">
					System
				</h3></p>
				<p align="center">
					Management
				</h3></p>
				<p align="center">
					Programs
				</h3></p>
			</td>
			<td width="145" valign="top">
				<p align="center">
					User
				</h3></p>
				<p align="center">
					Processes
				</h3></p>
			</td>
			<td width="143" valign="top">
				<p align="center">
					User
				</h3></p>
				<p align="center">
					Utility
				</h3></p>
				<p align="center">
					Programs
				</h3></p>
			</td>
			<td width="150" valign="top">
				<p align="center">
					Compilers
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="601" colspan="4" valign="top">
				<p align="center">
					System Shared Libraries
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="601" colspan="4" valign="top">
				<p align="center">
					Linux Kernels
				</h3></p>
			</td>
		</tr>
		<tr>
			<td width="601" colspan="4" valign="top">
				<p align="center">
					Loadable Kernel Modules
				</h3></p>
			</td>
		</tr>
	</tbody>
</table></center>
<p align="center">
	Fig 3.1 Components of the Linux system.
</h3></p>
<p><h3>
	Under Linux, no user-mode code is built into the kernel. Any
	operating-system-support code that does not need to run in kernel mode is
	placed into the system libraries instead.
</h3></p>
<p><h3>
	Although various modern operating systems have adopted a message passing
	architecture for their kernel internals, Linux retains UNIX's historical
	model: The kernel is created as a single, monolithic binary.
</h3></p>
<p><h3>
	The <strong><h2>main reason</h2></strong> is to improve performance: Because all
	kernel code and data structures are kept in a single address space, no
	context switches are necessary when a process calls an operating-system
	function or when a hardware interrupt is delivered.
</h3></p>
<p><h3>
	Not only <strong><h2>the core scheduling and virtual memory code</h2></strong>
	occupies this address space; all kernel code, including all device drivers,
	file systems, and networking code, is present in the same single address
	space.
</h3></p>
<p><h3>
	The <strong><h2>Linux kernel</h2></strong> forms the core of the Linux operating
	system. It provides all the functionality necessary to run processes, and
	it provides system services to give arbitrated and protected access to
	hardware resources.
</h3></p>
<p><h3>
	The <strong><h2>kernel implements</h2></strong> all the features required to qualify
	as an operating system. On its own, however, the operating system provided
	by the Linux kernel looks nothing like a UNIX system.
</h3></p>
<p><h3>
	The <strong><h2>operating-system interface</h2></strong> visible to running
	applications is not maintained directly by the kernel. Rather, applications
	make calls to the system libraries, which in turn call the operating system
	services as necessary.
</h3></p>
<p><h3>
	<strong><h2>The system libraries</h2></strong>
	provide many types of functionality. At the simplest level, they allow
	applications to make kernel-system-service requests. Making a system call
	involves transferring control from unprivileged user mode to privileged
	kernel mode; the details of this transfer vary from architecture to
	architecture.
</h3></p>
<p><h3>
	The <strong><h2>libraries</h2></strong> take care of collecting the system-call
	arguments and, if necessary, arranging those arguments in the special form
	necessary to make the system call.
</h3></p>
<p><h3>
	The libraries may also provide more complex versions of the basic system
	calls. <strong><h2>For example</h2></strong>, the C language's buffered
	file-handling functions are all implemented in the system libraries,
	providing more advanced control of file I/O than the basic kernel system
	calls.
</h3></p>
			
			
			
			</div><br/>


<hr/>
<div class="ads" id="ads" align="center">
Advertisement
<!-- Infolinks In-Article-Ad -->
<input type="hidden" name="IL_IN_ARTICLE">
</div>
<hr/>



<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript4')">Question 4<h1>Explain the different IPC mechanisms available in Linux. (05 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript4">
			
			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>4.1 Inter Process communication - IPC:</h2></strong>
</h3></p>
<p><h3>
	UNIX provides a rich environment for processes to communicate with each
	other. Communication may be just a matter of letting another process know
	that some event has occurred, or it may involve transferring data from one
	process to another.
</h3></p>
<p><h3>
	<strong><h2>4.2 Synchronization and Signals:</h2></strong>
</h3></p>
<p><h3>
	The standard UNIX <strong><h2>mechanism</h2></strong> for informing a process that
	an event has occurred is the signal. Signals can be sent from any process
	to any other process, with restrictions on signals sent to processes owned
	by another user. However, a limited number of signals are available, and
	they cannot carry information: Only the fact that a signal occurred is
	available to a process. Signals are not generated only by processes.
</h3></p>
<p><h3>
	The <strong><h2>kernel</h2></strong> also generates signals internally; for example,
	it can send a signal to a server process when data arrive on a network
	channel, to a parent process when a child terminates, or to a waiting
	process when a timer expires.
</h3></p>
<p><h3>
	Internally, the <strong><h2>Linux kernel</h2></strong> does not use signals to
communicate with processes running in kernel mode. If a	<strong><h2>kernel-mode process</h2></strong> is expecting an event to occur, it
	will not normally use signals to receive notification of that event.
	Rather, <strong><h2>communication</h2></strong> about incoming asynchronous events
	within the kernel is performed through the use of scheduling states and
	wait queue structures.
</h3></p>
<p><h3>
These <strong><h2>mechanisms</h2></strong> allow	<strong><h2>kernel-mode processes</h2></strong> to inform one another about relevant
	events, and they also allow events to be generated by device drivers or by
	the networking system. Whenever a process wants to wait for some event to
	complete, it places itself on a <strong><h2>wait queue</h2></strong> associated with
	that event and tells the scheduler that it is no longer eligible for
	execution.
</h3></p>
<p><h3>
	Once the event <strong><h2>has completed</h2></strong>, it will wake up every
	process on the wait queue. This procedure allows multiple processes to wait
for a single event. For example, if several processes are trying to	<strong><h2>read a file from a disk</h2></strong>, then they will all be awakened
	once the data have been read into memory successfully.
</h3></p>
<p><h3>
	<strong><h2>4.3 Passing of Data Among Processes:</h2></strong>
</h3></p>
<p><h3>
Linux offers several	<strong><h2>mechanisms for passing data among processes</h2></strong>. The standard
	UNIX pipe mechanism allows a child process to inherit a communication
	channel from its parent; data written to one end of the pipe can be read at
	the other.
</h3></p>
<p><h3>
	Under <strong><h2>Linux, pipes</h2></strong> appear as just another type of inode to
virtual-file system software, and each pipe has a pair of wait queues to<strong><h2>synchronize </h2></strong>the reader and writer. UNIX also	<strong><h2>defines</h2></strong> <strong><h2>a set of networking facilities</h2></strong>
	that can send streams of data to both local and remote processes.
</h3></p>
<p><h3>
Two other methods of sharing data among processes are available.	<strong><h2>First, shared memory </h2></strong>offers an extremely fast way to
	communicate large or small amounts of data; any data written by one process
	to a <strong><h2>shared memory region</h2></strong> can be read immediately by any
	other process that has mapped that region into its address space.
</h3></p>
<p><h3>
	The main <strong><h2>disadvantage of shared memory</h2></strong> is that, on its
	own, it offers no synchronization: A process can neither ask the operating
	system whether a piece of shared memory has been written to nor suspend
	execution until such a write occurs.
</h3></p>
<p><h3>
	Shared memory becomes particularly powerful when used in conjunction with
	another <strong><h2>inter-process-communication mechanism</h2></strong> that
	provides the missing synchronization.
</h3></p>
<p><h3>
	A <strong><h2>shared-memory region in Linux</h2></strong> is a persistent object
	that can be created or deleted by processes. Such an object is treated as
	though it were a small independent address space.
</h3></p>
<p><h3>
	The <strong><h2>Linux paging algorithms</h2></strong> can elect to page out to disk
	shared-memory pages, just as they can page out a process's data pages. The
	shared-memory object acts as a backing store for shared-memory regions,
	just as a file can act as a backing store for a memory-mapped memory
	region.
</h3></p>
<p><h3>
When a <strong><h2>file is mapped</h2></strong> into a	<strong><h2>virtual-address-space region</h2></strong>, then any page faults that
	occur cause the appropriate page of the file to be mapped into virtual
	memory.
</h3></p>
<p><h3>
	Similarly, <strong><h2>shared-memory mappings direct page faults</h2></strong> to
	map in pages from a persistent shared-memory object. Also just as for
	files, shared memory objects remember their contents even if no processes
	are currently mapping them into virtual memory.
</h3></p>
			
			
			
			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript5')">Question 5<h1>Explain process scheduling in a Linux system. (05 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript5">

			<h2>Answer:</h2>
			
			<p><h3>
	Linux has <strong><h2>two separate process-scheduling algorithms</h2></strong>.
</h3></p>
<p><h3>
	One is a <strong><h2>time-sharing algorithm</h2></strong> for fair, premptive
	scheduling among multiple processes.
</h3></p>
<p><h3>
	the other is designed for <strong><h2>real-time tasks</h2></strong>, where absolute
	priorities are more important than fairness.
</h3></p>
<p><h3>
	The scheduling algorithm used for routine, time-sharing tasks received a
	major overhaul with version 2.5 of the kernel. Prior to version 2.5, the
Linux kernel ran a variation of the traditional	<strong><h2>UNIX scheduling algorithm</h2></strong>.
</h3></p>
<p><h3>
	Among other issues, problems with the traditional UNIX scheduler are that
	it does not provide adequate support for SMP systems and that it does not
	scale well as the number of tasks on the system grows.
</h3></p>
<p><h3>
	The <strong><h2>overhaul</h2></strong> <strong><h2>of the scheduler</h2></strong> with
	version 2.5 of the kernel now provides a scheduling algorithm that runs in
	constant time-known <strong><h2>as O(l) </h2></strong>regardless of the number of
tasks on the system. The new scheduler also provides increased support for	<strong><h2>SMP</h2></strong>, including processor affinity and load balancing, as
	well as maintaining fairness and support for interactive tasks.
</h3></p>
<p><h3>
	The <strong><h2>Linux scheduler</h2></strong> is a pre-emptive, priority-based
	algorithm with two separate priority ranges: a real-time range from 0 to 99
	and a nice value ranging from 100 to 140. These two ranges map into a
	global priority scheme whereby numerically lower values indicate higher
	priorities.
</h3></p>
<p><h3>
	Unlike <strong><h2>schedulers f</h2></strong>or many other systems, Linux assigns
	higher-priority tasks longer time quanta and vice-versa. Because of the
	unique nature of the scheduler, this is appropriate for Linux, as we shall
	soon see. The relationship between priorities and time-slice length is
	shown in Figure 5.1.
</h3></p>
<p align="center">


			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/5.1.jpg" 
alt="Program" class="resIMG"/></center><br/>


</h3></p>
<p align="center">
	Fig 5.1 The relationship between priorities and time-slice length.
</h3></p>
<p><h3>
	A <strong><h2>runnable task is considered</h2></strong> eligible for execution on
	the <strong><h2>CPU</h2></strong> so long as it has time remaining in its time
slice. When a task has exhausted its time slice, it is considered	<strong><h2>expired</h2></strong> and is not eligible for execution again until all
	other tasks have also exhausted their time quanta.
</h3></p>
<p><h3>
	The kernel maintains a list of all <strong><h2>runnable</h2></strong> tasks in a run
	queue data structure. Because of its support for SMP, each processor
	maintains its own run queue and schedules itself independently. Each run
	queue contains two priority arrays <strong><h2>active and expired</h2></strong>.
</h3></p>
<p><h3>
	The <strong><h2>active array</h2></strong> contains all tasks with time remaining in
	their time slices, and the expired array contains all expired tasks. Each
	of these priority arrays includes a list of tasks indexed according to
	priority (Figure 5.2).
</h3></p>
<p align="center">


			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M5/SS/5.2.jpg" 
alt="Program" class="resIMG"/></center><br/>


</h3></p>
<p align="center">
	Fig 5.2 List of tasks indexed according to priority.
</h3></p>
<p><h3>
	The <strong><h2>scheduler chooses</h2></strong> the task with the highest priority
	from the active array for execution on the CPU. On multiprocessor machines,
	this means that each processor is scheduling the highest-priority task from
	its own run queue structure.
</h3></p>
<p><h3>
	When all tasks have <strong><h2>exhausted their time slices</h2></strong> (that is,
	the active array is empty), the two priority arrays are exchanged as the
	expired array becomes the active array and vice-versa
</h3></p>
			
			
			
			
			</div><br/>
			</div>

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	NOTE: Each Page Provides only 5 Questions & Answer<br/>Below Page NAVIGATION Links are Provided...<br/> All the Questions on Question 
	Bank Is SOLVED<br/>
    </div>




<hr/>
<div class="ads" id="ads" align="center">
Advertisement
<!-- Infolinks In-Article-Ad -->
<input type="hidden" name="IL_IN_ARTICLE">
</div>
<hr/>





<center>
<div id="showPGE">
  <button class="btn active" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M5/AS_OS_M5_P1.html'">1</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M5/AS_OS_M5_P2.html'">2</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M5/AS_OS_M5_P3.html'">3</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M5/AS_OS_M5_P4.html'">4</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M5/AS_OS_M5_P5.html'">5</button>
  
  
  
</div>
</center>

<br/><br/>
<!-- Answer Script -->



<div class="desp">

<p>
<H1>lIKE OUR CONTENT SUPPORT US BY FOLLOWING US ON INSTAGRAM : <a href="https://www.instagram.com/futurevisionbie/">@futurevisionbie</a></H1>
<h1>Latest Updates are also posted in instagram as Stories...</h1>
<h1>For immediate Notification Join the <a href="https://telegram.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ">Telegram Channel</a></h1>
</p>

</div>
<br/>
<br/>

 <hr/>
 
 
 
 
    <!-- call out 
	<div class="callout">
	  <div class="callout-header">Instagram :</div>
	  <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
	  <div class="callout-container" id="cooMSg">
	  <br/><br/><br/>
		<p id="coMSG" >Follow our Instagram Page: <br/><a href="https://www.instagram.com/futurevisionbie/">FutureVisionBIE</a><br/>
		<a href="https://www.instagram.com/futurevisionbie/">https://www.instagram.com/futurevisionbie/</a><br/><br/>
		Message: I'm Unable to Reply to all your Emails <br/>so, You can DM me on the Instagram Page & any other Queries.
		</p>

	  </div>
	</div>--->
 
 
 
 
 
 
 <button onclick="topFunction()" id="myBtnTOP" title="Go to top" style="font-size:40px;" class="animate-bottom" >&#8593;</button>

 
<br/><br/>
</article>

<footer>Copyright By Future Vision BIE 2018-2019 </footer>

</div>
</body>
</html>