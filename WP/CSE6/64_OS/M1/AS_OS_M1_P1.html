<!DOCTYPE html>
<html>
<head>
<!--ADSENSE-->
<script data-ad-client="ca-pub-3866146737734396" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146647335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146647335-1');
</script>
<title> ANSWER SCRIPT - OPERATING SYSTEMS </title>
<meta name="google-site-verification" content="google0186c8ef8f3bf22a.html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- indexing -->
<meta name="description" content="OPERATING SYSTEMS - ANSWER SCRIPT ">

<meta name="keywords" content="MODULE 1,OPERATING SYSTEMS,18CS43,17CS64,answer script,solution question paper,free">

<link rel="icon" type="image/ico" href="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" />


<link rel="stylesheet" href="https://hemanthrajhemu.github.io/FutureVisionBIE/style.css"/>			
<link rel="stylesheet" type="text/css" href="https://hemanthrajhemu.github.io/FutureVisionBIE/prints.css" media="print" />
		

</head>
<body onload="myFunction1()" style="margin:0;" oncopy="return false" onselectstart="return false">

<script src="https://hemanthrajhemu.github.io/FutureVisionBIE/script.js"> </script> 
<div id="loader"></div>
<div style="display:none;" id="myDiv" class="animate-bottom">
<div id="main">
<div class="container">
<!-- HEADER NAME WITH LOGO  -->
<header>
   <h1 class="FVBIE"><a href="https://hemanthrajhemu.github.io"><img src="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" alt="Future Vision BIE" style="float:left ;width:170px;height:140px;"></a>
   Future Vision BIE</h1><br/> <h1 class="FVBIE1">ONE STOP FOR ALL STUDY MATERIALS & LAB PROGRAMS</h1><br/>
   
</header>
<!-- TOP NAVIGATION TOOLS -->
<div class="topnav">
  
  <a class="openbtn" onclick="openNav()" style="font-family:courier; font-size:25px; text-align:center;">
	<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/menu.png" alt="E" style="width:38px;height:38px;"/>
	MENU
  </a>
  <a href="https://bit.ly/FVBIESHARE" style="float:right;" >
				<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/web.png" alt="Whatsapp Share" style="float:right; width:80px;height:40px;"/>
  </a>
  <a href="https://t.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ" style="float:right;">Join Telegram, to get Instant Updates</a>

</div>
<!--  NAVIGATION TOOLS -->
<div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">
		<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/cancel-64.png" alt="X" style="width:64px;height:64px;"/>
	</a><br/>
  
<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/disclaimer.html">Disclaimer</a>
    
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/JavaHtml/java.html">4th sem <br/>Java-DAA Programs</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE">5th sem CSE</br>Text Book</br>Programs</br></a>
    <a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/61_CNSCL/" rel="noopener noreferrer" target="_blank"> 17CS61 - CRYPTOGRAPHY, NETWORK SECURITY AND CYBER LAW </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/62_CGV/" rel="noopener noreferrer" target="_blank"> 17CS62 - COMPUTER GRAPHICS AND VISUALIZATION </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/63_SSCD/" rel="noopener noreferrer" target="_blank"> 17CS63 - SYSTEM SOFTWARE AND COMPILER DESIGN </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/64_OS/" rel="noopener noreferrer" target="_blank"> 17CS64 - OPERATING SYSTEMS </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/PE/" rel="noopener noreferrer" target="_blank"> 17CS65* -  Professional Elective</a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/OE/" rel="noopener noreferrer" target="_blank"> 17CS66* - Open Elective </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L67_SSOS/" rel="noopener noreferrer" target="_blank"> 17CSL67 - SYSTEM SOFTWARE AND OPERATING SYSTEM LABORATORY </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L68_CGL/" rel="noopener noreferrer" target="_blank"> 17CSL68 - COMPUTER GRAPHICS LABORATORY WITH MINI PROJECT </a>
		
	</br></br></br></br></br></br></br></br></br></br></br></br>
	
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/contact.html">CONTACT</a>
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/">HOME</a></br></br></br></br>
</div>
<!-- CENTER PATH FOR INFO  -->
<article>



	<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	  <strong>NOTE!</strong>
	  Click on MENU to Browse between Subjects...
	</div>

 <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 1
 </h1><h1>Solved Previous Year Question Paper
 </h1><h1>CBCS SCHEME</h1>
 
<br/>
</p></div>




<div class="desp">

<p>
<h1>OPERATING SYSTEMS</h1><h1>
[As per Choice Based Credit System (CBCS) scheme]</h1><h1>
(Effective from the academic year 2017 - 2018)</h1><h1>
SEMESTER - IV/VI</h1><h1>
Subject Code 18CS43/17CS64 </h1><h1>IA Marks 40</h1><h1>
Number of Lecture Hours/Week 3</h1><h1> Exam Marks 60 </h1>
</p>

</div>
<br/>

<!-- CONTENT AFTER LINK  -->

 <div class="desp" style="text-align: justify;"> 
 <h1>
 These Questions are being framed for helping the students in the "FINAL Exams" Only 
 (Remember for Internals the Question Paper is set by your respective teachers). 
 Questions may be repeated, just to show students how VTU can frame Questions.
<br/></h1>
<p style="color:green; font-family:courier; font-size:25px; text-align:right;">
-	ADMIN</p>

</h1>
</div>
<br/>



<!-- trying now--->
   <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 1
 

</p></div>
<br/>
<br/>


 <div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
 CLICK ON THE QUESTIONS TO VIEW ANSWER<br/></h1>
</div>
 <br/>
<!-- Answer Script -->

			<div class="ansCover">
			<div class="QAS"><a onclick="show('ANScript1')">Question 1<h1>What is operating system? Explain multiprogramming and time-sharing systems. (06 Marks) </h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript1">
			<p>
    <strong>1.1 Operating System:</strong>
</p>
<p>
    <strong>An operating system</strong>
    is a program that manages the computer hardware. It also provides a basis
    for application programs and acts as an intermediary between the computer
    user and the computer hardware.
</p>
<p>
    An <strong>operating system</strong> provides the environment within which
    programs are executed. Internally, operating systems vary greatly in their
    makeup, since they are organized along many different lines.
</p>
<p>
    One of the most important aspects of operating systems is the ability to
    multi-program. A single user cannot, in general, keep either the CPU or the
    I/O devices busy at all times.
</p>
<p>
    <strong> </strong>
</p>
<p>
    <strong>1.2 Multi-Programming System:</strong>
</p>
<p>
    <strong>Multiprogramming</strong>
    increases CPU utilization by organizing jobs (code and data) so that the
    CPU always has one to execute.
</p>
<p>
    The idea is as follows: The operating system keeps several jobs in memory
    simultaneously (Figure 1.1). This set of jobs can be a subset of the jobs
    kept in the job pool-which contains all jobs that enter the system-since
    the number of jobs that can be kept simultaneously in memory is usually
    smaller than the number of jobs that can be kept in the job pool. The
    operating system picks and begins to execute one of the jobs in memory.
    Eventually, the job may have to wait for some task, such as an I/O
    operation, to complete.
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/1.1.png" 
alt="Memory layout for a multiprogramming system" class="resIMG"/></center><br/>
</p>
<p align="center">
    Fig 1.1: Memory layout for a multiprogramming system.
</p>
<p>
    In a <strong>non-multiprogrammed</strong> system, the CPU would sit idle.
    In a <strong>multiprogrammed system</strong>, the operating system simply
    switches to, and executes, another job. When that job needs to wait, the
    CPU is switched to another job, and so on. Eventually, the first job
    finishes waiting and gets the CPU back. As long as at least one job needs
    to execute, the CPU is never idle.
</p>
<p>
    <strong>Multiprogrammed systems</strong>
    provide an environment in which the various system resources (for example,
    CPU, memory, and peripheral devices) are utilized effectively, but they do
    not provide for user interaction with the computer system.
</p>
<p>
    <strong>1.3 Time Shared System:</strong>
</p>
<p>
    <strong>Time sharing</strong>
    (or multitasking) is a logical extension of multiprogramming. In
    time-sharing systems, the CPU executes multiple jobs by switching among
    them, but the switches occur so frequently that the users can interact with
    each program while it is running.
</p>
<p>
    <strong>Time sharing</strong>
    requires an <strong>interactive</strong> (or hands-on) computer system,
which provides <strong>direct communication</strong> between the    <strong>user</strong> and the <strong>system</strong>.
</p>
<p>
    The <strong>user </strong>gives instructions to the operating system or to
    a program directly, using a input device such as a keyboard or a mouse, and
    waits for immediate results on an output device. Accordingly, the response
    time should be short-typically <strong>less than one second</strong>.
</p>
<p>
    A <strong>time-shared operating</strong> <strong>system</strong> allows
    many users to share the computer simultaneously. Since each action or
    command in a time-shared system tends to be short, only a little CPU time
    is needed for each user.
</p>
<p>
    As the system <strong>switches rapidly</strong> from one user to the next,
    each user is given the impression that the entire computer system is
    dedicated to his use, even though it is being shared among many users.
</p>
<p>
A <strong>time-shared operating system</strong> uses    <strong>CPU scheduling</strong> and <strong>multiprogramming</strong> to
    provide each user with a small portion of a time-shared computer. Each user
    has at least one separate program in memory.
</p>
<p>
In a time-sharing system, the <strong>operating system</strong> must ensure    <strong>reasonable response time</strong>, which is sometimes accomplished
through swapping, where processes are    <strong>swapped in and out of main memory to the disk</strong>. A more
    common method for achieving this goal is <strong>virtual memory</strong>, a
    technique that allows the execution of a process that is not completely in
    memory.
</p>
<p>
    Time-sharing systems must also provide a <strong>file system</strong>. The
file system resides on a <strong>collection of disks</strong>; hence,    <strong>disk management</strong> must be provided. Also, time-sharing
systems provide a mechanism for    <strong>protecting resources from inappropriate use</strong>. To ensure
orderly execution, the system must provide mechanisms for    <strong>job synchronization and communication</strong>, and it may
    <strong>
        ensure that jobs do not get stuck in a deadlock, forever waiting for
        one another.
    </strong>
</p>

			</div><br/>
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript2')">Question 2<h1>Explain dual mode operating in operating system with a neat block diagram. (05 Marks) </h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript2">
			<p>
    <strong>2.1 Dual Mode Operation:</strong>
</p>
<p>
    In order to ensure the proper execution of the operating system, we must be
    able to distinguish between the execution of operating-system code and user
    defined code. The approach taken by most computer systems is to provide
    hardware support that allows us to differentiate among various modes of
    execution.
</p>
<p>
At the very least, we need two separate modes of operation:    <strong>user mode</strong> and <strong>kernel mode</strong> (also called
    supervisor mode, system mode, or privileged mode)
</p>
<p>
A bit, called the <strong>mode bit</strong>, is added to the<strong>hardware of the computer</strong> to indicate the current mode:    <strong>kernel (0) or user (1).</strong> With the mode bit, we are able to
    distinguish between a task that is executed on behalf of the operating
    system and one that is executed on behalf of the user.
</p>
<p>
    When the computer system is executing on behalf of a user application, the
    system is in user mode. However, when a user application requests a service
    from the operating system (via a system call), it must transition from user
    to kernel mode to fulfill the request. This is shown in Figure 2.1.
</p>
<p>
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/2.1.png" 
alt="Transition from user to kernel mode" class="resIMG"/></center><br/>
</p>
<p align="center">
    Fig 2.1: Transition from user to kernel mode.
</p>
<p>
    At system boot time, the hardware starts in <strong>kernel mode</strong>.
    The operating system is then loaded and starts user applications in user
    mode. Whenever a <strong>trap or interrupt occurs</strong>, the hardware
    switches from <strong>user mode to kernel mode</strong> (that is, changes
    the state of the mode bit to 0). Thus, whenever the
    <strong>
        operating system gains control of the computer, it is in kernel mode
    </strong>
. The system always    <strong>switches to user mode (by setting the mode bit to 1)</strong>
    before passing control to a user program.
</p>
<p>
The <strong>dual mode of operation</strong> provides us with the means for<strong>protecting the operating system</strong> from    <strong>errant users-and errant users</strong> from one another. We
    accomplish this protection by designating some of the machine instructions
    that may cause harm as <strong>privileged instructions</strong>.
</p>
<p>
    The hardware allows privileged instructions to be executed only in kernel
    mode. If an attempt is made to execute a privileged instruction in user
    mode, the hardware does not execute the instruction but rather treats it as
    illegal and traps it to the operating system.
</p>
<p>
    The instruction to switch to user mode is an example of a privileged
    instruction. Some other examples include I/O control, timer management, and
    interrupt management.
</p>
<p>
    The lack of a hardware-supported dual mode can cause serious shortcomings
    in an operating system. For instance, MS-DOS was written for the Intel 8088
    architecture, which has no mode bit and therefore no dual mode. A user
    program running awry can wipe out the operating system by writing over it
    with data; and multiple programs are able to write to a device at the same
    time, with possibly disastrous results.
</p>

			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript3')">Question 3<h1>What are system calls? Briefly point out its types. (05 Marks) </h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript3">
<p>
	<strong>3.1 System calls:</strong>
</p>
<p>
	System calls provide an interface to the services made available by an
	operating system. These calls are generally available as routines written
	in C and C++, although certain low-level tasks (for example, tasks where
	hardware must be accessed directly), may need to be written using
	assembly-language instructions.
</p>
<p>
	<strong>3.2 Types of System calls:</strong>
</p>
<p>
	System calls can be grouped roughly into five major categories:
</p>
<p>
	i. process control,
</p>
<p>
	ii. file manipulation,
</p>
<p>
	iii. device manipulation,
</p>
<p>
	iv. information maintenance, and
</p>
<p>
	v. communications.
</p>
<p>
	<strong>3.2.1 Process Control:</strong>
</p>
<p>
	A running program needs to be able to halt its execution either normally
	(end) or abnormally (abort). If a system call is made to terminate the
	currently running program abnormally, or if the program runs into a problem
	and causes an error trap, a dump of memory is sometimes taken and an error
	message generated. The dump is written to disk and may be examined by a
	debugger a system program designed to aid the programmer in finding and
	correcting bugs to determine the cause of the problem.
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/3.1.png" 
alt="Types of system calls" class="resIMG"/></center><br/>
</p>
<p align="center">
	Fig 3.1: Types of system calls.
</p>
<p>
	<strong>3.2.2 File Management</strong>
</p>
<p>
	We first need to be able to create and delete files. Either system call
	requires the name of the file and perhaps some of the file's attributes.
	Once the file is created, we need to open it and to use it. We may also
	read, write, or reposition (rewinding or skipping to the end of the file,
	for example). Finally, we need to close the file, indicating that we are no
	longer using it.
</p>
<p>
	We may need these same sets of operations for directories if we have a
	directory structure for organizing files in the file system. In addition,
	for either files or directories, we need to be able to determine the values
	of various attributes and perhaps to reset them if necessary.
</p>
<p>
	File attributes include the file name, a file type, protection codes,
	accounting information, and so on. At least two system calls, get file
	attribute and set fil e attribute, are required for this function. Some
	operating systems provide many more calls, such as calls for file move and
	copy
</p>
<p>
	<strong>3.2.3 Device Management</strong>
</p>
<p>
	A process may need several resources to execute-main memory, disk drives,
	access to files, and so on. If the resources are available, they can be
	granted, and control can be returned to the user process. Otherwise, the
	process will have to wait until sufficient resources are available.
</p>
<p>
	The various resources controlled by the operating system can be thought of
	as devices. Some of these devices are physical devices (for example,
	tapes), while others can be thought of as abstract or virtual devices (for
	example, files). If there are multiple users of the system, the system may
	require us to first request the device, to ensure exclusive use of it.
</p>
<p>
	After we are finished with the device, we release it. These functions are
	similar to the open and close system calls for files. Other operating
	systems allow unmanaged access to devices. The hazard then is the potential
	for device contention and perhaps deadlock.
</p>
<p>
	Once the device has been requested (and allocated to us), we can read,
	write, and (possibly) reposition the device, just as we can with files. In
	fact, the similarity between I/O devices and files is so great that many
	operating systems, including UNIX, merge the two into a combined
	file-device structure. In this case, a set of system calls is used on files
	and devices. Sometimes, I/O devices are identified by special file names,
	directory placement, or file attributes
</p>
<p>
	<strong>3.2.4 Information Maintenance</strong>
</p>
<p>
	Many system calls exist simply for the purpose of transferring information
	between the user program and the operating system. For example, most
	systems have a system call to return the current time and date. Other
	system calls may return information about the system, such as the number of
	current users, the version number of the operating system, the amount of
	free memory or disk space, and so on.
</p>
<p>
	In addition, the operating system keeps information about all its
	processes, and system calls are used to access this information. Generally,
	calls are also used to reset the process information (get process attribute
	s and s e t process attributes).
</p>
<p>
	<strong>3.2.5 Communication</strong>
</p>
<p>
	There are two common models of inter process communication: the message
	passing model and the shared-memory model. In the message-passing model,
	the communicating processes exchange messages with one another to transfer
	information. Messages can be exchanged between the processes either
	directly or indirectly through a common mailbox.
</p>
<p>
	Before communication can take place, a connection must be opened. The name
	of the other communicator must be known, be it another process on the same
	system or a process on another computer connected by a communications
	network. Each computer in a network has a host name by which it is commonly
	known.
</p>
<p>
	A host also has a network identifier, such as an IP address. Similarly,
	each process has a process name, and this name is translated into an
	identifier by which the operating system can refer to the process. The get
	host id and get process id system calls do this translation. The
	identifiers are then passed to the general purpose open and close calls
	provided by the file system or to specific open connection and close
	connection system calls, depending on the system's model of communication.
</p>
<p>
	The recipient process usually must give its permission for communication to
	take place with an accept connection call. Most processes that will be
	receiving connections are special-purpose daemons, which are systems
	programs provided for that purpose.
</p>
<p>
	They execute a wait for connect ion call and are awakened when a connection
	is made. The source of the communication, known as the client, and the
	receiving daemon, known as a server, then exchange messages by using read
	message and write message system calls. The close connection call
	terminates the communication.
</p>

			</div><br/>
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript4')">Question 4<h1>Explain process states with state transition diagram. Also explain PCB with a neat diagram. (06 Marks) </h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript4">
			
<p>
	<strong>4.1 Process State:</strong>
</p>
<p>
	As a process executes, it changes state. The state of a process is defined
	in part by the current activity of that process. Each process may be in one
	of the following states:
</p>
<p>
	i. <strong>New</strong>: The process is being created.
</p>
<p>
	ii. <strong>Running</strong>: Instructions are being executed.
</p>
<p>
	iii. <strong>Waiting</strong>: The process is waiting for some event to
	occur (such as an I/O completion or reception of a signal).
</p>
<p>
	iv. <strong>Ready:</strong> The process is waiting to be assigned to a
	processor.
</p>
<p>
	v. <strong>Terminated:</strong> The process has finished execution.
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/4.1.png" 
alt="State Diagram of Process" class="resIMG"/></center><br/>
</p>
<p align="center">
	Fig 4.1: State Diagram of Process.
</p>
<p>
	These names are arbitrary, and they vary across operating systems. The
	states that they represent are found on all systems, however. Certain
	operating systems also more finely delineate process states. It is
	important to realize that only one process can be running on any processor
	at any instant. Many processes may be ready and limiting, however. The
	state diagram corresponding to these states is presented in Figure 4.1.
</p>
<p>
	<strong>4.2 Process Control Block</strong>
</p>
<p>
Each process is represented in the operating system by a<strong>process control block (PCB)</strong>-also called a	<strong>task control block</strong>. A PCB is shown in Figure 4.2. It
	contains many pieces of information associated with a specific process,
	including these:
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/4.2.png" 
alt="Process control block (PCB)" class="resIMG"/></center><br/>
</p>
<p align="center">
	Fig 4.2 : Process control block (PCB)
</p>
<p>
	i. <strong>Process state:</strong> The state may be new, ready, running,
	waiting, halted, and so on.
</p>
<p>
	ii. <strong>Program counter:</strong> The counter indicates the address of
	the next instruction to be executed for this process.
</p>
<p>
	iii. <strong>CPU registers:</strong> The registers vary in number and type,
	depending on the computer architecture. They include accumulators, index
	registers, stack pointers, and general-purpose registers, plus any
	condition-code information. Along with the program counter, this state
	information must be saved when an interrupt occurs, to allow the process to
	be continued correctly afterward.
</p>
<p>
	iv. <strong>CPU-scheduling information:</strong> This information includes
	a process priority, pointers to scheduling queues, and any other scheduling
	parameters.
</p>
<p>
	v. <strong>Memory-management information:</strong> This information may
	include such information as the value of the base and limit registers, the
	page tables, or the segment tables, depending on the memory system used by
	the operating system.
</p>
<p>
	vi. <strong>Accounting information:</strong> This information includes the
	amount of CPU and real time used, time limits, account numbers, job or
	process numbers, and so on.
</p>
<p>
	vii. <strong>I/O status information:</strong> This information includes the
	list of I/O devices allocated to the process, a list of open files, and so
	on.
</p>

			
			
			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript5')">Question 5<h1>What is inter process communication? Explain its type. (05 Marks) </h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript5">
			
			<p>
	<strong>5.1 Inter Process Communication (IPC):</strong>
</p>
<p>
	Processes executing concurrently in the operating system may be either
independent processes or cooperating processes. A process is	<strong>independent</strong> if it cannot affect or be affected by the
	other processes executing in the system. Any process that does not share
	data with any other process is independent.
</p>
<p>
	A process is <strong>cooperating</strong> if it can affect or be affected
	by the other processes executing in the system. Clearly, any process that
	shares data with other processes is a cooperating process.
</p>
<p>
	There are several reasons for providing an environment that allows process
	cooperation:
</p>
<p>
	i. <strong>Information sharing</strong>: Since several users may be
	interested in the same piece of information (for instance, a shared file),
	we must provide an environment to allow concurrent access to such
	information.
</p>
<p>
	ii. <strong>Computation speedup:</strong> If we want a particular task to
	run faster, we must break it into subtasks, each of which will be executing
	in parallel with the others. Notice that such a speedup can be achieved
	only if the computer has multiple processing elements (such as CPUs or I/O
	channels).
</p>
<p>
	iii. <strong>Modularity:</strong> We may want to construct the system in a
	modular fashion, dividing the system functions into separate processes or
	threads.
</p>
<p>
	iv. <strong>Convenience:</strong> Even an individual user may work on many
	tasks at the same time. For instance, a user may be editing, printing, and
	compiling in parallel.
</p>
<p>
	<strong>5.2 Types of IPC's:</strong>
</p>
<p>
	<strong>Cooperating processes</strong>
	require an <strong>inter process communication (IPC)</strong> mechanism
	that will allow them to exchange data and information. There are two
	fundamental models of inter process communication:
</p>
<p>
	(1) <strong>shared memory</strong> and
</p>
<p>
	(2)<strong> message passing</strong>.
</p>
<p>
	In the <strong>shared-memory model</strong>, a region of memory that is
	shared by cooperating processes is established. Processes can then exchange
	information by reading and writing data to the shared region.
</p>
<p>
	In the <strong>message passing model,</strong> communication takes place by
	means of messages exchanged between the cooperating processes.
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M1/SS/1.1.png" 
alt="Communications models, (a) Message passing, (b) Shared memory." class="resIMG"/></center><br/>
</p>
<p align="center">
	Fig 5.1: Communications models, (a) Message passing, (b) Shared memory.
</p>
<p>
	<strong>5.2.1 Shared-Memory Systems</strong>
</p>
<p>
	Inter process communication using shared memory requires communicating
	processes to establish a region of shared memory. Typically, a
	shared-memory region resides in the address space of the process creating
	the shared-memory segment. Other processes that wish to communicate using
	this shared-memory segment must attach it to their address space. Recall
	that, normally, the operating system tries to prevent one process from
	accessing another process's memory.
</p>
<p>
	Shared memory requires that two or more processes agree to remove this
	restriction. They can then exchange information by reading and writing data
	in the shared areas.
</p>
<p>
	The form of the data and the location are determined by these processes and
	are not under the operating system's control. The processes are also
	responsible for ensuring that they are not writing to the same location
	simultaneously.
</p>
<p>
	To illustrate the concept of cooperating processes, let's consider the
	producer-consumer problem, which is a common paradigm for cooperating
	processes. A producer process produces information that is consumed by a
	consumer process.
</p>
<p>
	For example, a compiler may produce assembly code, which is consumed by an
	assembler. The assembler, in turn, may produce object modules, which are
	consumed by the loader. The producer-consumer problem also provides a
	useful metaphor for the client-server paradigm.
</p>
<p>
	One solution to the producer-consumer problem uses shared memory. To allow
	producer and consumer processes to run concurrently, we must have available
	a buffer of items that can be filled by the producer and emptied by the
	consumer. This buffer will reside in a region of memory that is shared by
	the producer and consumer processes.
</p>
<p>
	A producer can produce one item while the consumer is consuming another
	item. The producer and consumer must be synchronized, so that the consumer
	does not try to consume an item that has not yet been produced.
</p>
<p>
	<strong>Two types of buffers</strong>
	can be used: The <strong>unbounded buffer</strong> places no practical
	limit on the size of the buffer. The consumer may have to wait for new
items, but the producer can always produce new items. The	<strong>bounded buffer</strong> assumes a fixed buffer size. In this case,
	the consumer must wait if the buffer is empty, and the producer must wait
	if the buffer is full.
</p>
<p>
	<strong>5.2.2 Message-Passing Systems:</strong>
</p>
<p>
	Message passing provides a mechanism to allow processes to communicate and
	to synchronize their actions without sharing the same address space and is
	particularly useful in a distributed environment, where the communicating
	processes may reside on different computers connected by a network.
</p>
<p>
	For example, a chat program used on the World Wide Web could be designed so
	that chat participants communicate with one another by exchanging messages.
</p>
<p>
A message-passing facility provides at least two operations:	<strong>send(message) and receive(message).</strong> Messages sent by a
	process can be of either fixed or variable size. If only fixed-sized
	messages can be sent, the system-level implementation is straightforward.
</p>
<p>
	This restriction, however, makes the task of programming more difficult.
	Conversely, variable-sized messages require a more complex system-level
	implementation, but the programming task becomes simpler. This is a common
	kind of trade off seen throughout operating system design
</p>
<p>
	If processes P and Q want to communicate, they must send messages to and
	receive messages from each other; a communication link must exist between
	them. This link can be implemented in a variety of ways. We are concerned
	here not with the link's physical implementation but rather with its
	logical implementation. Here are several methods for logically implementing
	a link and the send()/receive () operations:
</p>
<p>
	i. Direct or indirect communication
</p>
<p>
	ii. Synchronous or asynchronous communication
</p>
<p>
	iii. Automatic or explicit buffering
</p>

			
			
			</div><br/>
			</div>

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	NOTE: Each Page Provides only 5 Questions & Answer<br/>Below Page NAVIGATION Links are Provided...<br/> All the Questions on Question 
	Bank Is SOLVED<br/>
    </div>



<center>
<div id="showPGE">
  <button class="btn active" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P1.html'">1</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P2.html'">2</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P3.html'">3</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P4.html'">4</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P5.html'">5</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P6.html'">6</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P7.html'">7</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P8.html'">8</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P9.html'">9</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M1/AS_OS_M1_P10.html'">10</button>
  
  
</div>
</center>

<br/><br/>
<!-- Answer Script -->

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	SUGGESTION: SHARE WITH ALL THE STUDENTS AND FRIENDS -ADMIN
    </div>


 <hr/>
 
 
 
 
    <!-- call out 
	<div class="callout">
	  <div class="callout-header">Instagram :</div>
	  <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
	  <div class="callout-container" id="cooMSg">
	  <br/><br/><br/>
		<p id="coMSG" >Follow our Instagram Page: <br/><a href="https://www.instagram.com/futurevisionbie/">FutureVisionBIE</a><br/>
		<a href="https://www.instagram.com/futurevisionbie/">https://www.instagram.com/futurevisionbie/</a><br/><br/>
		Message: I'm Unable to Reply to all your Emails <br/>so, You can DM me on the Instagram Page & any other Queries.
		</p>

	  </div>
	</div>--->
 
 
 
 
 
 
 
 
<br/><br/>
</article>

<footer>Copyright By Future Vision BIE 2018-2019 </footer>

</div>
</div>
</div>
</body>
</html>