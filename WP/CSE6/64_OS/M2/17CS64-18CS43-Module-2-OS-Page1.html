<!DOCTYPE html>
<html lang="en">
<head>
<!--ADSENSE-->
<script data-ad-client="ca-pub-3866146737734396" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146647335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146647335-1');
</script>
<title> ANSWER SCRIPT - OPERATING SYSTEMS </title>
<meta name="google-site-verification" content="google0186c8ef8f3bf22a.html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- indexing -->
<meta name="description" content="OPERATING SYSTEMS - ANSWER SCRIPT, Solved OS Paper , Module 2 ">

<meta name="keywords" content="MODULE 2,OPERATING SYSTEMS,18CS43,17CS64,answer script,solved paper, cbcs, vtu 17 scheme, vtu, 18 scheme, OS Notes, OS solved, Previous paper solved, paper solved, os paper">

<link rel="icon" type="image/ico" href="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" />


<link rel="stylesheet" href="https://hemanthrajhemu.github.io/FutureVisionBIE/style.css"/>			
<link rel="stylesheet" type="text/css" href="https://hemanthrajhemu.github.io/FutureVisionBIE/prints.css" media="print" />
		

<script src="https://hemanthrajhemu.github.io/FutureVisionBIE/script.js"> </script>
</head>
<body oncopy="return false" onselectstart="return false">
<div id="main">
<!-- HEADER NAME WITH LOGO  -->
<header>
   <h1 class="FVBIE"><a href="https://hemanthrajhemu.github.io"><img src="https://hemanthrajhemu.github.io/FutureVisionBIE/logo.png" alt="Future Vision BIE" style="float:left ;width:170px;height:140px;"></a>
   Future Vision BIE</h1><br/> <h1 class="FVBIE1">ONE STOP FOR ALL STUDY MATERIALS & LAB PROGRAMS</h1><br/>
   
</header>
<!-- TOP NAVIGATION TOOLS -->
<div class="topnav">
  
  <a class="openbtn" onclick="openNav()" style="font-family:courier; font-size:25px; text-align:center;">
	<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/menu.png" alt="E" style="width:38px;height:38px;"/>
	MENU
  </a>
  <a href="https://bit.ly/FVBIESHARE" style="float:right;" >
				<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/web.png" alt="Whatsapp Share" style="float:right; width:80px;height:40px;"/>
  </a>
  <a href="https://t.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ" style="float:right;">Join Telegram, to get Instant Updates</a>

</div>
<!--  NAVIGATION TOOLS -->
<div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">
		<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/cancel-64.png" alt="X" style="width:64px;height:64px;"/>
	</a><br/>
  
<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/disclaimer.html">Disclaimer</a>
    
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/JavaHtml/java.html">4th sem <br/>Java-DAA Programs</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE">5th sem CSE<br/>Text Book<br/>Programs<br/></a>
    <a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/61_CNSCL/"> 17CS61 - CRYPTOGRAPHY, NETWORK SECURITY AND CYBER LAW </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/62_CGV/"> 17CS62 - COMPUTER GRAPHICS AND VISUALIZATION </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/63_SSCD/"> 17CS63 - SYSTEM SOFTWARE AND COMPILER DESIGN </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/64_OS/"> 17CS64 - OPERATING SYSTEMS </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/PE/"> 17CS65* -  Professional Elective</a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/OE/"> 17CS66* - Open Elective </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L67_SSOS/"> 17CSL67 - SYSTEM SOFTWARE AND OPERATING SYSTEM LABORATORY </a>
	<a href="https://hemanthrajhemu.github.io/CSE6/17SCHEME/L68_CGL/"> 17CSL68 - COMPUTER GRAPHICS LABORATORY WITH MINI PROJECT </a>
		
	<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
	
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/contact.html">CONTACT</a>
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/">HOME</a><br/><br/><br/><br/>
</div>
<!-- CENTER PATH FOR INFO  -->
<article>



	<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	  <strong>NOTE!</strong>
	  Click on MENU to Browse between Subjects...
	</div>


<hr/>
<div class="ads" id="ads" align="center">
<!--ADVERTISEMENT HORTIZONAL_INTERACTIVE -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3866146737734396"
     data-ad-slot="6261199289"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<hr/>



 <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 2
 </h1><h1>Solved Previous Year Question Paper
 </h1><h1>CBCS SCHEME</h1>
 
<br/>
</p></div>




<div class="desp">

<p>
<h1>OPERATING SYSTEMS</h1><h1>
[As per Choice Based Credit System (CBCS) scheme]</h1><h1>
(Effective from the academic year 2017 - 2018)</h1><h1>
SEMESTER - IV/VI</h1><h1>
Subject Code 18CS43/17CS64 </h1><h1>IA Marks 40</h1><h1>
Number of Lecture Hours/Week 3</h1><h1> Exam Marks 60 </h1>
</p>

</div>
<br/>



<hr/>
<div class="ads" id="ads" align="center">
<!--ADVERTISEMENT SQUARE_INTERACTIVE -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3866146737734396"
     data-ad-slot="9598056486"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<hr/>



<!-- CONTENT AFTER LINK  -->

 <div class="desp" style="text-align: justify;"> 
 <h1>
 These Questions are being framed for helping the students in the "FINAL Exams" Only 
 (Remember for Internals the Question Paper is set by your respective teachers). 
 Questions may be repeated, just to show students how VTU can frame Questions.
<br/></h1>
<p style="color:green; font-family:courier; font-size:25px; text-align:right;">
-	ADMIN</p>

</h1>
</div>
<br/>



<!-- trying now--->
   <div class="desp" style="text-align:center;"> 
 <h1>
18CS43/17CS64 - OPERATING SYSTEMS
 </h1><h1> 4<SUP>TH</SUP> & 6<SUP>TH</SUP> SEMESTER ISE & CSE
 </h1><h1>Answer Script for Module 2
 

</p></div>
<br/>
<br/>


 <div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
 CLICK ON THE QUESTIONS TO VIEW ANSWER<br/></h1>
</div>
 <br/>
<!-- Answer Script -->

			<div class="ansCover">
			<div class="QAS"><a onclick="show('ANScript1')">Question 1<h1>For the process listed below, draw Gantt charts using pre-emptive and
	non-pre-emptive priority scheduling algorithm. Calculate Average Weighing
	Time and Average turnaround time.<br/><center>
<table cellspacing="auto" cellpadding="auto" border="10">
	<tbody>
		<tr>
			<td width="150" valign="top">
				<p>
					<strong>Jobs</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					<strong>Arrival Time</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					<strong>Burst Time</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					<strong>Priority</strong>
				</p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p>
					<strong>J1</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					0
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					6
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					4
				</p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p>
					<strong>J2</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					3
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					5
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					2
				</p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p>
					<strong>J3</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					3
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					3
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					6
				</p>
			</td>
		</tr>
		<tr>
			<td width="150" valign="top">
				<p>
					<strong>J4</strong>
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					5
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					3
				</p>
			</td>
			<td width="150" valign="top">
				<p>
					3
				</p>
			</td>
		</tr>
	</tbody>
</table></center>
	(6 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript1">
			
			<h2>Answer:</h2>
			
			
			<h2>1.1 Premptive priority scheduling algorithm:</h2>
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/1.1.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
			
			
			<h2>1.2 non-premptive priority scheduling algorithm:</h2>
			
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/1.2.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
			
			</div><br/>
			


<hr/>
<div class="ads" id="ads" align="center">
<!--ADVERTISEMENT SQUARE_INTERACTIVE -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3866146737734396"
     data-ad-slot="9598056486"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<hr/>



<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript2')">Question 2<h1>Is CPU scheduling necessary? Discuss the five different scheduling criteriaâ€™s used in the computing scheduling mechanism. (05 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript2">
			
			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>2.1 CPU Scheduling:</h2></strong>
</h3></p>
<p><h3>
	<strong><h2>CPU scheduling</h2></strong>
	is the basis of multi-programmed operating systems. By switching the CPU
	among processes, the operating system can make the computer more
	productive. So therefore CPU Scheduling is necessary.
</h3></p>
<p><h3>
	<strong><h2>2.2 Scheduling Criteria's:</h2></strong>
</h3></p>
<p><h3>
	Different CPU scheduling algorithms have different properties, and the
	choice of a particular algorithm may favour one class of processes over
	another. In choosing which algorithm to use in a particular situation, we
	must consider the properties of the various algorithms.
</h3></p>
<p><h3>
	Many criteria have been suggested for comparing CPU scheduling algorithms.
	Which characteristics are used for comparison can make a substantial
	difference in which algorithm is judged to be best. The criteria include
	the following:
</h3></p>
<p><h3>
	<strong><h2>i. CPU utilization:</h2></strong>
	We want to keep the CPU as busy as possible. Conceptually, CPU utilization
	can range from 0 to 100 percent. In a real system, it should range from 40
	percent (for a lightly loaded system) to 90 percent (for a heavily used
	system).
</h3></p>
<p><h3>
	<strong><h2>ii. Throughput:</h2></strong>
	If the CPU is busy executing processes, then work is being done. One
	measure of work is the number of processes that are completed per time
	unit, called throughput. For long processes, this rate may be one process
	per hour; for short transactions, it may be 10 processes per second.
</h3></p>
<p><h3>
	<strong><h2>iii. Turnaround time:</h2></strong>
	From the point of view of a particular process, the important criterion is
	how long it takes to execute that process. The interval from the time of
	submission of a process to the time of completion is the turnaround time.
	Turnaround time is the sum of the periods spent waiting to get into memory,
	waiting in the ready queue, executing on the CPU, and doing I/O.
</h3></p>
<p><h3>
	<strong><h2>iv. Waiting time:</h2></strong>
	The CPU scheduling algorithm does not affect the amount of time during
	which a process executes or does I/O; it affects only the amount of time
	that a process spends waiting in the ready queue. Waiting time is the sum
	of the periods spent waiting in the ready queue.
</h3></p>
<p><h3>
	<strong><h2>v. Response time:</h2></strong>
	In an interactive system, turnaround time may not be the best criterion.
	Often, a process can produce some output fairly early and can continue
	computing new results while previous results are being output to the user.
	Thus, another measure is the time from the submission of a request until
	the first response is produced. This measure, called response time, is the
	time it takes to start responding, not the time it takes to output the
	response. The turnaround time is generally limited by the speed of the
	output device.
</h3></p>
<p><h3>
	It is desirable to maximize CPU utilization and throughput and to minimize
	turnaround time, waiting time, and response time. In most cases, we
	optimize the average measure. However, under some circumstances, it is
	desirable to optimize the minimum or maximum values rather than the
	average. For example, to guarantee that all users get good service, we may
	want to minimize the maximum response time.
</h3></p>

			
			
			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript3')">Question 3<h1>Explain Multithreading models. (05 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript3">

			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>3.1 Multithreading Models:</h2></strong>
</h3></p>
<p><h3>
	i. There are two types of threads to be managed in a modern system: User
	threads and kernel threads.
</h3></p>
<p><h3>
	ii. User threads are the threads that application programmers would put
	into their programs. They are supported above the kernel, without kernel
	support.
</h3></p>
<p><h3>
	iii. Kernel threads are supported within the kernel of the OS itself. All
	modern OS support kernel level threads, allowing the kernel to perform
	multiple tasks simultaneously.
</h3></p>
<p><h3>
	iv. In a specific implementation, the user threads must be mapped to kernel
	threads, using one of the following models.
</h3></p>
<p><h3>
	There are three Models in Multithreading &amp; Are as follows:
</h3></p>
<p><h3>
	i. Many-to-one Model
</h3></p>
<p><h3>
	ii. One-to-One Model
</h3></p>
<p><h3>
	iii. Many-to-Many Model
</h3></p>
<p><h3>
	<strong><h2>3.1.1 Many-To-One Model</h2></strong>
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/3.1.jpg" 
alt="Many-to-One Model" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 3.1 Many-to-One Model
</h3></p>
<p><h3>
	i. In the many-to-one model, many user-level threads are all mapped onto a
	single kernel thread.
</h3></p>
<p><h3>
	ii. Thread management is handled by the thread library in user space, which
	is very efficient.
</h3></p>
<p><h3>
	iii. If a blocking system call is made by one of the threads, then the
	entire process blocks. Thus blocking the other user threads from continuing
	the execution.
</h3></p>
<p><h3>
	iv. Only one user thread can access the kernel at a time, as there is only
	one kernel thread. Thus the threads are unable to run in parallel on
	multiprocessors.
</h3></p>
<p><h3>
	v. Green threads of Solaris and GNU Portable Threads implement the
	many-to-one model.
</h3></p>
<p><h3>
	<strong><h2>3.1.2 One-to-One Model:</h2></strong>
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/3.2.jpg" 
alt="One-to-One Model" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 3.2 One-to-One Model
</h3></p>
<p><h3>
	i. The one-to-one model creates a separate kernel thread to handle each
	user thread.
</h3></p>
<p><h3>
	ii. One-to-one model overcomes the problems listed above involving blocking
	system calls and the splitting of processes across multiple CPUs.
</h3></p>
<p><h3>
	iii. However, the overhead of managing the one-to-one model is more
	significant, involving more overhead and slowing down the system.
</h3></p>
<p><h3>
	iv. This model places a limit on the number of threads created.
</h3></p>
<p><h3>
	v. Linux and Windows from 95 to XP implement the one-to-one model for
	threads.
</h3></p>
<p><h3>
	<strong><h2>3.1.3 Many-to-Many Model:</h2></strong>
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/3.3.jpg" 
alt="Many-to-Many Model" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 3.3 Many-to-Many Model
</h3></p>
<p><h3>
	i. The many-to-many model multiplexes any number of user threads onto an
	equal or smaller number of kernel threads, combining the best features of
	the one-to-one and many-to-one models.
</h3></p>
<p><h3>
	ii. Users have no restrictions on the number of threads created.
</h3></p>
<p><h3>
	iii. Blocking kernel system calls do not block the entire process.
</h3></p>
<p><h3>
	iv. Processes can be split across multiple processors.
</h3></p>
<p><h3>
	v. Individual processes may be allocated variable numbers of kernel
	threads, depending on the number of CPUs present and other factors.
</h3></p>
<p><h3>
	vi. This model is also called as two-tier model.
</h3></p>
<p><h3>
	vii. It is supported by operating system such as IRIX, HP-UX, and Tru64
	UNIX.
</h3></p>

			
			
			
			</div><br/>


<hr/>
<div class="ads" id="ads" align="center">
<!--ADVERTISEMENT SQUARE_INTERACTIVE -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3866146737734396"
     data-ad-slot="9598056486"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<hr/>



<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript4')">Question 4<h1>Define Semaphores. Explain its usage and implementation. (06 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript4">
			
			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>4.1 Semaphores:</h2></strong>
</h3></p>
<p><h3>
	The various hardware-based solutions to the critical-section problem (using
	the TestAndSet( ) and Swap( ) instructions) are complicated for application
	programmers to use. To overcome this difficulty, we can use a
	synchronization tool called a semaphore.
</h3></p>
<p><h3>
	A semaphore S is an integer variable that, apart from initialization, is
	accessed only through two standard atomic operations: wait( ) and signal(
	). The wait( ) operation was originally termed P (from the Dutch probercn,
	"to test"); signal( ) was originally called V (from verhogen, "to
	increment"). The definition of wait 0 is as follows:
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/4.1.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p><h3>
	<strong><h2>4.2 Semaphore Usage:</h2></strong>
</h3></p>
<p><h3>
	Operating systems often distinguish between counting and binary semaphores.
</h3></p>
<p><h3>
	The value of a counting semaphore can range over an unrestricted domain.
	The value of a binary semaphore can range only between 0 and 1.
</h3></p>
<p><h3>
	On some systems, binary semaphores are known as mutex locks, as they are
	locks that provide mutual exclusion.
</h3></p>
<p><h3>
	We can use binary semaphores to deal with the critical-section problem for
	multiple processes. The n processes share a semaphore, mutex, initialized
	to 1. Each process P, is organized as shown in Figure 4.2.
</h3></p>
<p><h3>
	Counting semaphores can be used to control access to a given resource
	consisting of a finite number of instances. The semaphore is initialized to
	the number of resources available.
</h3></p>
<p><h3>
	Each process that wishes to use a resource performs a wait( ) operation on
	the semaphore (thereby decrementing the count). When a process releases a
	resource, it performs a signal () operation (incrementing the count). When
	the count for the semaphore goes to 0, all resources are being used. After
	that, processes that wish to use a resource will block until the count
	becomes greater than 0.
</h3></p>
<p><h3>
	We can also use semaphores to solve various synchronization problems. For
	example, consider two concurrently running processes: P<sub>1</sub> with a
	statement S<sub>1</sub> and P<sub>2</sub> with a statement S<sub>2</sub>.
	Suppose we require that S<sub>2</sub> be executed only after S<sub>1</sub>
has completed. We can implement this scheme readily by letting P	<sub>1</sub> and P<sub>2</sub> share a common semaphore synch, initialized
	to 0, and by inserting the statements
</h3></p>
<p><h3>
	<em>S1; </em>
</h3></p>
<p><h3>
	<em>signal(synch);</em>
</h3></p>
<p><h3>
	in process P<sub>1</sub>, and the statements
</h3></p>
<p><h3>
	<em>wait(synch); </em>
</h3></p>
<p><h3>
	<em>S2;</em>
</h3></p>
<p><h3>
	in process P<sub>2</sub>. Because synch is initialized to 0, P<sub>2</sub>
	will execute S<sub>2</sub> only after P<sub>1</sub> has invoked signal
	(synch), which is after statement S<sub>1</sub> has been executed.
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/4.2.jpg" 
alt="Mutual-exclusion implementation with semaphores." class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 4.2 Mutual-exclusion implementation with semaphores.
</h3></p>
<p><h3>
	<strong><h2>4.3 Semaphore Implementation:</h2></strong>
</h3></p>
<p><h3>
	The main disadvantage of the semaphore definition given here is that it
	requires busy waiting. While a process is in its critical section, any
	other process that tries to enter its critical section must loop
	continuously in the entry code. This continual looping is clearly a problem
	in a real multiprogramming system, where a single CPU is shared among many
	processes.
</h3></p>
<p><h3>
	Busy waiting wastes CPU cycles that some other process might be able to use
	productively. This type of semaphore is also called a spinlock because the
	process "spins" while waiting for the lock. (Spinlocks do have an advantage
	in that no context switch is required when a process must wait on a lock,
	and a context switch may take considerable time.
</h3></p>
<p><h3>
	Thus, when locks are expected to be held for short times, spinlocks are
	useful; they are often employed on multiprocessor systems where one thread
	can "spin" on one processor while another thread performs its critical
	section on another processor.)
</h3></p>
<p><h3>
	To overcome the need for busy waiting, we can modify the definition of the
	wait( ) and signal( ) semaphore operations. When a process executes the
	wait( ) operation and finds that the semaphore value is not positive, it
	must wait. However, rather than engaging in busy waiting, the process can
	block itself.
</h3></p>
<p><h3>
	The block operation places a process into a waiting queue associated with
	the semaphore, and the state of the process is switched to the waiting
	state. Then control is transferred to the CPU scheduler, which selects
	another process to execute.
</h3></p>
<p><h3>
	A process that is blocked, waiting on a semaphore S, should be restarted
	when some other process executes a signal( ) operation. The process is
	restarted by a wakeup( ) operation, which changes the process from the
	waiting state to the ready state.
</h3></p>
<p><h3>
	The process is then placed in the ready queue. (The CPU may or may not be
	switched from the running process to the newly ready process, depending on
	the CPU-scheduling algorithm.)
</h3></p>
<p><h3>
	To implement semaphores under this definition, we define a semaphore as a
	"C" struct:
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/4.3.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p><h3>
	Each semaphore has an integer value and a list of processes list. When a
	process must wait on a semaphore, it is added to the list of processes. A
	signal( ) operation removes one process from the list of waiting processes
	and awakens that process.
</h3></p>
<p><h3>
	The wait () semaphore operation can now be defined as
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/4.4.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p><h3>
	The signal 0 semaphore operation can now be defined as
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/4.5.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p><h3>
	The block( ) operation suspends the process that invokes it. The wakeup(P)
	operation resumes the execution of a blocked process P. These two
	operations are provided by the operating system as basic system calls.
</h3></p>

			
			
			
			
			</div><br/>
			
			
 
			
			
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript5')">Question 5<h1>Explain Reader-Write problem with semaphore in detail. (05 Marks)</h1></a></div>
			<div class="ansclass  animate-bottom" id="ANScript5">

			<h2>Answer:</h2>
			
			
			<p><h3>
	<strong><h2>5.1 Classical Problems of Synchronization are as follows:</h2></strong>
</h3></p>
<p><h3>
	i. Bounded-Buffer Problem
</h3></p>
<p><h3>
	ii. Readers and Writers Problem
</h3></p>
<p><h3>
	iii. Dining-Philosophers Problem
</h3></p>
<p><h3>
	<strong><h2>5.2 Reader-Write problem with Semaphore:</h2></strong>
</h3></p>
<p><h3>
	A database is to be shared among several concurrent processes. Some of
	these processes may want only to read the database, whereas others may want
	to update (that is, to read and write) the database.
</h3></p>
<p><h3>
	We distinguish between these two types of processes by referring to the
	former as readers and to the latter as <strong><h2>writers</h2></strong>. Obviously,
	if two readers access the shared data simultaneously, no adverse affects
	will result. However, if a writer and some other thread (either a reader or
	a writer) access the database simultaneously, chaos may ensue.
</h3></p>
<p><h3>
	To ensure that these difficulties do not arise, we require that the writers
	have exclusive access to the shared database. This synchronization problem
	is referred to as the <strong><h2>readers-writers problem</h2></strong>. Since it
	was originally stated, it has been used to test nearly every new
	synchronization primitive.
</h3></p>
<p><h3>
	The readers-writers problem has several variations, all involving
	priorities. The simplest one, referred to as the first readers-writers
	problem, requires that no reader will be kept waiting unless a writer has
	already obtained permission to use the shared object. In other words, no
	reader should wait for other readers to finish simply because a writer is
	waiting.
</h3></p>
<p><h3>
	The second readers-writers problem requires that, once a writer is ready,
	that writer performs its write as soon as possible. In other words, if a
	writer is waiting to access the object, no new readers may start reading.
</h3></p>
<p><h3>
	A solution to either problem may result in starvation. In the first case,
	writers may starve; in the second case, readers may starve. For this
	reason, other variants of the problem have been proposed.
</h3></p>
<p><h3>
	we present a solution to the first readers-writers problem. Refer to the
	bibliographical notes at the end of the chapter for references describing
	starvation-free solutions to the second readers-writers problem.
</h3></p>
<p><h3>
	In the solution to the first readers-writers problem, the reader processes
	share the following data structures:
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/5.1.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p><h3>
	The semaphores mutex and wrt are initialized to 1; readcount is initialized
	to 0. The semaphore wrt is common to both reader and writer processes. The
	mutex semaphore is used to ensure mutual exclusion when the variable
	readcount is updated.
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/5.2.jpg" 
alt="Loading Image" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 5.2 The structure of a writer process.
</h3></p>
<p><h3>
	The readcount variable keeps track of how many processes are currently
	reading the object. The semaphore wrt functions as a mutual-exclusion
	semaphore for the writers. It is also used by the first or last reader that
	enters or exits the critical section. It is not used by readers who enter
	or exit while other readers are in their critical sections.
</h3></p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/CSE6/64_OS/M2/SS/5.3.jpg" 
alt="The structure of a reader processe" class="resIMG"/></center><br/>
</h3></p>
<p align="center">
	Fig 5.3 
</h3></p>
<p><h3>
	The code for a writer process is shown in Figure 5.2; the code for a reader
	process is shown in Figure 5.3. Note that, if a writer is in the critical
	section and n readers are waiting, then one reader is queued on wrt, and n
	- 1 readers are queued on mutex. Also observe that, when a writer executes
	signal (wrt), we may resume the execution of either the waiting readers or
	a single waiting writer. The selection is made by the scheduler.
</h3></p>
<p><h3>
	The readers-writers problem and its solutions has been generalized to
	provide reader-writer locks on some systems. Acquiring a reader-writer lock
	requires specifying the mode of the lock: either read or write access.
</h3></p>
<p><h3>
	When a process only wishes to read shared data, it requests the
	reader-writer lock in read mode; a process wishing to modify the shared
	data must request the lock in write mode. Multiple processes are permitted
	to concurrently acquire a reader-writer lock in read mode; only one process
	may acquire the lock for writing as exclusive access is required for
	writers
</h3></p>
<p><h3>
	<strong><h2>
		5.2 Reader-writer locks are most useful in the following situations:
	</h2></strong>
</h3></p>
<p><h3>
	i. In applications where it is easy to identify which processes only read
	shared data and which threads only write shared data.
</h3></p>
<p><h3>
	ii. In applications that have more readers than writers. This is because
	reader-writer locks generally require more overhead to establish than
	semaphores or mutual exclusion locks, and the overhead for setting up a
	reader-writer lock is compensated by the increased concurrency of allowing
	multiple readers.
</h3></p>

			
			
			
			</div><br/>
			</div>

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	NOTE: Each Page Provides only 5 Questions & Answer<br/>Below Page NAVIGATION Links are Provided...<br/> All the Questions on Question 
	Bank Is SOLVED<br/>
    </div>




<hr/>
<div class="ads" id="ads" align="center">
<!-- ADVERTISEMENT IN-FEED AD-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="fluid"
     data-ad-layout-key="-7b+dr-1o-43+n4"
     data-ad-client="ca-pub-3866146737734396"
     data-ad-slot="8739065100"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<hr/>





<center>
<div id="showPGE">
  <button class="btn active" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M2/17CS64-18CS43-Module-2-OS-Page1.html'">1</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M2/17CS64-18CS43-Module-2-OS-Page2.html'">2</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M2/17CS64-18CS43-Module-2-OS-Page3.html'">3</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M2/17CS64-18CS43-Module-2-OS-Page4.html'">4</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/CSE6/64_OS/M2/17CS64-18CS43-Module-2-OS-Page5.html'">5</button>
  
  
  
</div>
</center>

<br/><br/>

<div class="desp">

<p>
<H1>lIKE OUR CONTENT SUPPORT US BY FOLLOWING US ON INSTAGRAM : <a href="https://www.instagram.com/futurevisionbie/">@futurevisionbie</a></H1>
<h1>For immediate Notification Join the <a href="https://telegram.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ">Telegram Channel</a></h1>
</p>

</div>
<br/>
<br/>
<!-- Answer Script -->

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	SUGGESTION: SHARE WITH ALL THE STUDENTS AND FRIENDS -ADMIN
    </div>


 <hr/>
 
 
 
 
    <!-- call out 
	<div class="callout">
	  <div class="callout-header">Instagram :</div>
	  <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
	  <div class="callout-container" id="cooMSg">
	  <br/><br/><br/>
		<p id="coMSG" >Follow our Instagram Page: <br/><a href="https://www.instagram.com/futurevisionbie/">FutureVisionBIE</a><br/>
		<a href="https://www.instagram.com/futurevisionbie/">https://www.instagram.com/futurevisionbie/</a><br/><br/>
		Message: I'm Unable to Reply to all your Emails <br/>so, You can DM me on the Instagram Page & any other Queries.
		</p>

	  </div>
	</div>--->
 
 
 
 
 
 
 <button onclick="topFunction()" id="myBtnTOP" title="Go to top" style="font-size:40px;" class="animate-bottom" >&#8593;</button>

 
<br/><br/>
</article>

<footer>Copyright By Future Vision BIE 2018-2019 </footer>

</div>
</body>
</html>