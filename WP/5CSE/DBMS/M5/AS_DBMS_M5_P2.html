<!DOCTYPE html>
<html>
<head>
<!--ADSENSE-->
<script data-ad-client="ca-pub-3866146737734396" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Infolinks -->
<script type="text/javascript">
var infolinks_pid = 3211351;
var infolinks_wsid = 0;
</script>
<script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146647335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146647335-1');
</script>
<title> ANSWER SCRIPT - DBMS </title>
<meta name="google-site-verification" content="google0186c8ef8f3bf22a.html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- indexing -->
<meta name="description" content="17CS53 DATABASE MANAGEMENT SYSTEM  - ANSWER SCRIPT ">

<meta name="keywords" content="Future Visiob BIE,hemanth raj,VTU,Question paper,previous year,17CS53,DATABASE MANAGEMENT SYSTEM,
 SOLVED PAPER DBMS, DBMS SOLVED QB">

<link rel="icon" type="image/ico" href="/FutureVisionBIE/logo.png" />


<link rel="stylesheet" href="https://hemanthrajhemu.github.io/FutureVisionBIE/style.css"/>			
		

</head>
<body onload="myFunction1()" style="margin:0;" oncopy="return false" onselectstart="return false">

<script src="https://hemanthrajhemu.github.io/FutureVisionBIE/script.js"> </script> 
<div id="loader"></div>
<div style="display:none;" id="myDiv" class="animate-bottom">
<div id="main">
<div class="container">
<!-- HEADER NAME WITH LOGO  -->
<header>
   <h1 class="FVBIE"><a href="https://hemanthrajhemu.github.io"><img src="/FutureVisionBIE/logo.png" alt="Future Vision BIE" style="float:left ;width:170px;height:140px;"></a>
   Future Vision BIE</h1><br/> <h1 class="FVBIE1">ONE STOP FOR ALL STUDY MATERIALS & LAB PROGRAMS</h1><br/>
   
</header>
<!-- TOP NAVIGATION TOOLS -->
<div class="topnav">
  
  <a class="openbtn" onclick="openNav()" style="font-family:courier; font-size:25px; text-align:center;">
	<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/menu.png" alt="E" style="width:38px;height:38px;"/>
	MENU
  </a>
  <a href="https://bit.ly/FVBIESHARE" style="float:right;" >
				<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/web.png" alt="Whatsapp Share" style="float:right; width:80px;height:40px;"/>
  </a>
  <a href="https://t.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ" style="float:right;">Join Telegram, to get Instant Updates</a>

</div>
<!--  NAVIGATION TOOLS -->
<div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">
		<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/cancel-64.png" alt="X" style="width:64px;height:64px;"/>
	</a><br/>
  
<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/disclaimer.html">Disclaimer</a>
    
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/JavaHtml/java.html">4th sem <br/>Java-DAA Programs</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE">5th sem CSE</br>Text Book</br>Programs</br></a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/M&T.html">17CS51 -<br/> MANAGEMENT AND ENTREPRENEURSHIP FOR IT INDUSTRY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/CN.html"> 17CS52 -<br/> COMPUTER NETWORKS</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/DBMS.html"> 17CS53 -<br/> DATABASE MANAGEMENT SYSTEM</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/ATC.html">17CS54 -<br/> AUTOMATA THEORY AND COMPUTABILITY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AVD_JAVA.html">17CS553  -<br/> ADVANCED JAVA AND J2EE</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AI.html">17CS562 -<br/> ARTIFICIAL INTELLIGENCE</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/LAB_CN.html">17CSL57 -<br/> COMPUTER NETWORK LABORATORY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/LAB_DBMS.html">17CSL58 -<br/> DBMS LABORATORY WITH MINI PROJECT</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AVD_ALGO.html">17CS554 - ADVANCED ALGORITHMS </a>
    
	</br></br></br></br></br></br></br></br></br></br></br></br>
	
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/contact.html">CONTACT</a>
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/">HOME</a></br></br></br></br>
</div>
<!-- CENTER PATH FOR INFO  -->
<article>



	<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	  <strong>NOTE!</strong>
	  Click on MENU to Browse between Subjects...
	</div>

 <div class="desp" style="text-align:center;"> 
 <h1>
17CS53 - DATABASE MANAGEMENT SYSTEM
 </h1><h1>
 </h1><h1>Answer Script for Module 5
 </h1><h1>Solved Previous Year Question Paper
 </h1><h1>CBCS SCHEME</h1>
 
<br/>
</p></div>




 <div class="desp" style="text-align:center;"> 
 <h1>
DATABASE MANAGEMENT SYSTEM 
 </h1><h1>DBMS
 </h1><h1>[As per Choice Based Credit System (CBCS) scheme]
 </h1><h1>(Effective from the academic year 2019 -2020)
 </h1><h1>SEMESTER - V<br/>
 </h1><h1>Subject Code 17CS53 			       	   <br/>     IA Marks 40
 </h1><h1>Number of Lecture Hours/Week 04 	<br/>	Exam Marks 60</h1>
<br/>
</p></div>

<hr/>

<!-- CONTENT AFTER LINK  -->

 <div class="desp" style="text-align: justify;"> 
 <h1>
 These Questions are being framed for helping the students in the "FINAL Exams" Only 
 (Remember for Internals the Question Paper is set by your respective teachers). 
 Questions may be repeated, just to show students how VTU can frame Questions.
<br/></h1>
<p style="color:green; font-family:courier; font-size:25px; text-align:right;">
-	ADMIN</p>
<br/>
</h1>
</div>
<br/>
<br/>

 <div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
 CLICK ON THE QUESTIONS TO VIEW ANSWER<br/></h1>
</div>
 <br/>
<!-- trying now--->
  

<!-- Answer Script -->

			<div class="ansCover">
			<div class="QAS"><a onclick="show('ANScript1')">Question 6<h1>Explain transaction support in SQL. (6-Marks) (9b)</h1></a></div>
			<div class="ansclass" id="ANScript1">
			
			<p>
	There are many more details, and the newer standards have more commands for
	transaction processing. The basic definition of an SQL transaction is
	similar to our already defined concept of a transaction. That is, it is a
	logical unit of work and is guaranteed to be atomic. A single SQL statement
	is always considered to be atomic-either it completes execution without an
	error or it fails and leaves the database unchanged.
</p>
<p>
	With SQL, there is no explicit Begin_Transaction statement. Transaction
	initiation is done implicitly when particular SQL statements are
	encountered. However, every transaction must have an explicit end
	statement, which is either a COMMIT or a ROLLBACK. Every transaction has
	certain characteristics attributed to it. These characteristics are
	specified by a SET TRANSACTION statement in SQL. The characteristics are
	the access mode, the diagnostic area size, and the isolation level.
</p>
<p>
	The <strong>access mode</strong> can be specified as READ ONLY or READ
	WRITE. The default is READ WRITE, unless the isolation level of READ
	UNCOMMITTED is specified (see below), in which case READ ONLY is assumed. A
	mode of READ WRITE allows select, update, insert, delete, and create
	commands to be executed. A mode of READ ONLY, as the name implies, is
	simply for data retrieval.
</p>
<p>
	The <strong>diagnostic area</strong> size option, DIAGNOSTIC SIZE n,
	specifies an integer value n, which indicates the number of conditions that
	can be held simultaneously in the diagnostic area. These conditions supply
	feedback information (errors or exceptions) to the user or program on the n
	most recently executed SQL statement.
</p>
<p>
	<strong>The isolation level</strong>
	option is specified using the statement ISOLATION LEVEL , where the value
	for can be READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, or
	SERIALIZABLE. 15 The default isolation level is SERIALIZABLE, although some
	systems use READ COMMITTED as their default. The use of the term
	SERIALIZABLE here is based on not allowing violations that cause dirty
	read, unrepeatable read, and phantoms,
</p>
<p>
	If a transaction executes at a lower isolation level than SERIALIZABLE,
	then one or more of the following three violations may occur:
</p>
<p>
	a. <strong>Dirty read:</strong> A transaction T1 may read the update of a
	transaction T2, which has not yet committed. If T2 fails and is aborted,
	then T1 would have read a value that does not exist and is incorrect.
</p>
<p>
	b. <strong>Non-repeatable read:</strong> A transaction T1 may read a given
	value from a table. If another transaction T2 later updates that value and
	T1 reads that value again, T1 will see a different value.
</p>
<p>
	c. <strong>Phantoms:</strong> A transaction T1 may read a set of rows from
	a table, perhaps based on some condition specified in the SQL WHERE-clause.
	Now suppose that a transaction T2 inserts a new row r that also satisfies
	the WHERE-clause condition used in T1, into the table used by T1. The
	record r is called a phantom record because it was not there when T1 starts
	but is there when T1 ends. T1 may or may not see the phantom, a row that
	previously did not exist. If the equivalent serial order is T1 followed by
	T2, then the record r should not be seen; but if it is T2 followed by
	T1,then the phantom record should be in the result given to T1. If the
	system cannot ensure the correct behavior, then it does not deal with the
	phantom record problem.
</p>
<p align="center">
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/DBMS/M5/M5IMG/6.1.png" 
alt="Loading Image" class="resIMG"/></center>
</p>
<p align="center">
	Table 6.1: Possible Violations Based on Isolation Levels as Defined in SQL
</p>
<p>
	Table 6.1 summarizes the possible violations for the different isolation
	levels. An entry of Yes indicates that a violation is possible and an entry
	of No indicates that it is not possible. READ UNCOMMITTED is the most
	forgiving, and SERIALIZABLE is the most restrictive in that it avoids all
	three of the problems mentioned above.
</p>
<p>
	A sample SQL transaction might look like the following:
</p>
<p>
			<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/DBMS/M5/M5IMG/6.2.png" 
alt="Loading Image" class="resIMG"/></center>
</p>
<p>
	The above transaction consists of first inserting a new row in the EMPLOYEE
	table and then updating the salary of all employees who work in department
	2. If an error occurs on any of the SQL statements, the entire transaction
	is rolled back. This implies that any updated salary (by this transaction)
	would be restored to its previous value and that the newly inserted row
	would be removed.
</p>

			
			</div><br/>
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript2')">Question 7<h1>Discuss the UNDO and REDO operation and the recovery techniques that use each. (6-Marks) (9c)</h1></a></div>
			<div class="ansclass" id="ANScript2">
			
			<p>
	In the <strong>immediate update techniques</strong>, the database may be
	updated by some operations of a transaction before the transaction reaches
	its commit point. However, these operations must also be recorded in the
	log on disk by force-writing before they are applied to the database on
	disk, making recovery still possible. If a transaction fails after
	recording some changes in the database on disk but before reaching its
	commit point, the effect of its operations on the database must be undone;
	that is, the transaction must be rolled back.
</p>
<p>
	In the general case of immediate update, both undo and redo may be required
during recovery. This technique, known as the	<strong>UNDO/REDO algorithm</strong>, requires both operations during
	recovery and is used most often in practice.
</p>
<p>
	A variation of the algorithm where all updates are required to be recorded
in the database on disk <em>before</em> a transaction commits requires<em>undo</em> only, so it is known as the	<strong>UNDO/NO-REDO algorithm</strong>.
</p>
<p>
	The UNDO and REDO operations are required to be <strong>idempotent</strong>
	-that is, executing an operation multiple times is equivalent to executing
	it just once. In fact, the whole recovery process should be idempotent
	because if the system were to fail during the recovery process, the next
	recovery attempt might UNDO and REDO certain write_item operations that had
	already been executed during the first recovery process. The result of
	recovery from a system crash during recovery should be the same as the
	result of recovering when there is no crash during recovery!
</p>
<p>
	<strong>7.1 Recovery Techniques Based on Immediate Update</strong>
</p>
<p>
	In these techniques, when a transaction issues an update command, the
	database on disk can be updated immediately, without any need to wait for
	the transaction to reach its commit point. Notice that it is not a
	requirement that every update be applied immediately to disk; it is just
	possible that some updates are applied to disk before the transaction
	commits.
</p>
<p>
	Provisions must be made for undoing the effect of update operations that
	have been applied to the database by a failed transaction. This is
	accomplished by rolling back the transaction and undoing the effect of the
transaction's write_item operations. Therefore, the<strong>UNDO-type log entries</strong>, which include the	<strong>old value (BFIM</strong>) of the item, must be stored in the log.
Because UNDO can be needed during recovery, these methods follow a	<strong>steal strategy</strong> for deciding when updated main memory
	buffers can be written back to disk
</p>
<p>
	Theoretically, we can distinguish two main categories of immediate update
	algorithms
</p>
<p>
	i. If the recovery technique ensures that all updates of a transaction are
	recorded in the database on disk before the transaction commits, there is
	never a need to <strong>REDO</strong> any operations of committed
transactions. This is called the	<strong>UNDO/NO-REDO recovery algorithm</strong>. In this method, all
	updates by a transaction must be recorded on disk before the transaction
	commits, so that <strong>REDO is never needed</strong>. Hence, this method
	must utilize the steal/force strategy for deciding when updated main memory
	buffers are written back to disk
</p>
<p>
	ii. If the transaction is allowed to commit before all its changes are
written to the database, we have the most general case, known as the	<strong>UNDO/REDO recovery algorithm</strong>. In this case, the
	steal/no-force strategy is applied. This is also the most complex
	technique, but the most commonly used in practice. We will outline an
	UNDO/REDO recovery algorithm and leave it as an exercise for the reader to
	develop the UNDO/NO-REDO variation
</p>
<p>
	Procedure RIU_M (UNDO/REDO with checkpoints).
</p>
<p>
	a. Use two lists of transactions maintained by the system: the committed
	transactions since the last checkpoint and the active transactions.
</p>
<p>
	b. Undo all the write_item operations of the active (uncommitted)
	transactions, using the UNDO procedure. The operations should be undone in
	the reverse of the order in which they were written into the log.
</p>
<p>
	c. Redo all the write_item operations of the committed transactions from
	the log, in the order in which they were written into the log, using the
	REDO procedure defined earlier.
</p>
<p>
	The UNDO procedure is defined as follows:
</p>
<p>
	Procedure UNDO (WRITE_OP). Undoing a write_item operation write_op consists
	of examining its log entry [write_item, T, X, old_value, new_value] and
	setting the value of item X in the database to old_value, which is the
	before image (BFIM). Undoing a number of write_item operations from one or
	more transactions from the log must proceed in the reverse order from the
	order in which the operations were written in the log.
</p>

			
			</div><br/>
			
			
<!-- inArticle ad-->
			<div class="ads" id="ads">
			<center>Advertisement<br/>
			<input type="hidden" name="IL_IN_ARTICLE">
			</center>
			</div>
			
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript3')">Question 8<h1>What is two – phase locking protocol? How does it guarantee serializability? 		(4-Marks) (10a)</h1></a></div>
			<div class="ansclass" id="ANScript3">
			
			
<br/><br/>
			Refer 3<sup>rd</sup> Question & Answer OR <a href="/AnswerScript/WP/5CSE/DBMS/M5/AS_DBMS_M5_P1.html">CLICK HERE</a>
			<br/><br/>	
			
			
			</div><br/>
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript4')">Question 9<h1>What is Serializability? How can Serializability be ensured? Do you need to restrict concurrent execution of transaction to ensure serializability? Justify your answer. (6-Marks) (10b)</h1></a></div>
			<div class="ansclass" id="ANScript4">
			
			<p>
	The definition of serializable schedule is as follows: A schedule S of n
	transactions is serializable if it is equivalent to some serial schedule of
	the same n transactions.
</p>
<p>
	<strong>9.1 How Serializability Is Used for Concurrency Control</strong>
	<strong></strong>
</p>
<p>
	A schedule S is (conflict) serializable-that is, S is (conflict) equivalent
	to a serial schedule-is tantamount to saying that S is correct. Being
	serializable is distinct from being serial, however.
</p>
<p>
	A serial schedule represents inefficient processing because no interleaving
	of operations from different transactions is permitted. This can lead to
	low CPU utilization while a transaction waits for disk I/O, or for a long
	transaction to delay other transactions, thus slowing down transaction
	processing considerably.
</p>
<p>
	A serializable schedule gives the benefits of concurrent execution without
	giving up any correctness. In practice, it is difficult to test for the
	serializability of a schedule. The interleaving of operations from
	concurrent transactions-which are usually executed as processes by the
	operating system-is typically determined by the operating system scheduler,
	which allocates resources to all processes. Factors such as system load,
	time of transaction submission, and priorities of processes contribute to
	the ordering of operations in a schedule. Hence, it is difficult to
	determine how the operations of a schedule will be interleaved beforehand
	to <strong>ensure serializability</strong>.
</p>
<p>
	If transactions are executed at will and then the resulting schedule is
	tested for serializability, we must cancel the effect of the schedule if it
	turns out not to be serializable. This is a serious problem that makes this
	approach impractical. The approach taken in most commercial DBMSs is to
	design protocols (sets of rules) that-if followed by every individual
	transaction or if enforced by a DBMS concurrency control subsystem-will
	ensure serializability of all schedules in which the transactions
	participate. Some protocols may allow non-serializable schedules in rare
	cases to reduce the overhead of the concurrency control method.
</p>

			
			</div><br/>
			
			
<hr/>		
<!-- inTag ad-->
			<div class="ads" id="ads">
			<center>Advertisement<br/>
			<input type="hidden" name="IL_IN_TAG" value="2"/>
			</center>
			</div>	
<hr/>	
			
			
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript5')">Question 10<h1>Discuss the time – stamp ordering protocol for concurrency control. (6-Marks) (10c)</h1></a></div>
			<div class="ansclass" id="ANScript5">
			
			<p>
	<strong>10.1 Introduction:</strong>
</p>
<p>
	A timestamp is a unique identifier created by the DBMS to identify a
	transaction. Typically, timestamp values are assigned in the order in which
	the transactions are submitted to the system, so a timestamp can be thought
	of as the transaction start time. We will refer to the timestamp of
	transaction T as TS(T). Concurrency control techniques based on timestamp
	ordering do not use locks; hence, deadlocks cannot occur.
</p>
<p>
	Timestamps can be generated in several ways. One possibility is to use a
	counter that is incremented each time its value is assigned to a
	transaction. The transaction timestamps are numbered 1, 2, 3, &#8230; in
	this scheme. A computer counter has a finite maximum value, so the system
	must periodically reset the counter to zero when no transactions are
	executing for some short period of time.
</p>
<p>
	<strong>
		10.2 The Timestamp Ordering Algorithm for Concurrency Control:
	</strong>
</p>
<p>
	The idea for this scheme is to enforce the equivalent serial order on the
	transactions based on their timestamps. A schedule in which the
	transactions participate is then serializable, and the only equivalent
	serial schedule permitted has the transactions in order of their timestamp
	values. This is called timestamp ordering (TO).
</p>
<p>
	Notice how this differs from 2PL, where a schedule is serializable by being
	equivalent to some serial schedule allowed by the locking protocols. In
	timestamp ordering, however, the schedule is equivalent to the particular
	serial order corresponding to the order of the transaction timestamps.
</p>
<p>
	The algorithm allows interleaving of transaction operations, but it must
	ensure that for each pair of conflicting operations in the schedule, the
	order in which the item is accessed must follow the timestamp order. To do
	this, the algorithm associates with each database item X two timestamp (TS)
	values:
</p>
<p>
	a. read_TS(X). The read timestamp of item X is the largest timestamp among
	all the timestamps of transactions that have successfully read item X-that
	is, read_TS(X) = TS(T), where T is the youngest transaction that has read X
	successfully.
</p>
<p>
	b. write_TS(X). The write timestamp of item X is the largest of all the
	timestamps of transactions that have successfully written item X-that is,
	write_TS(X) = TS(T), where T is the youngest transaction that has written X
	successfully. Based on the algorithm, T will also be the last transaction
	to write item X.
</p>
<p>
	<strong>10.2.1 </strong>
	<strong>Basic Timestamp Ordering (TO):</strong>
</p>
<p>
	Whenever some transaction T tries to issue a read_item(X) or a
	write_item(X) operation, the <strong>basic TO</strong> algorithm compares
	the timestamp of T with read_TS(X) and write_TS(X) to ensure that the
	timestamp order of transaction execution is not violated. If this order is
	violated, then transaction T is aborted and resubmitted to the system as a
	new transaction with <strong>a new timestamp</strong>.
</p>
<p>
	If T is aborted and rolled back, any transaction T1 that may have used a
	value written by T must also be rolled back. Similarly, any transaction T2
	that may have used a value written by T1 must also be rolled back, and so
	on. This effect is known as <strong>cascading rollback</strong> and is one
	of the problems associated with basic TO, since the schedules produced are
	not guaranteed to be recoverable.
</p>
<p>
	An additional protocol must be enforced to ensure that the schedules are
	recoverable, cascadeless, or strict. We first describe the basic TO
	algorithm here. The concurrency control algorithm must check whether
	conflicting operations violate the timestamp ordering in the following two
	cases:
</p>
<p>
	<strong>i. </strong>
	<strong>
		Whenever a transaction T issues a write_item(X) operation, the
		following check is performed:
	</strong>
</p>
<p>
	a. If read_TS(X) &gt; TS(T) or if write_TS(X) &gt; TS(T), then abort and
	roll back T and reject the operation. This should be done because some
	younger transaction with a timestamp greater than TS(T)-and hence after T
	in the timestamp ordering-has already read or written the value of item X
	before T had a chance to write X, thus violating the timestamp ordering.
</p>
<p>
	b. If the condition in part (a) does not occur, then execute the
	write_item(X) operation of T and set write_TS(X) to TS(T).
</p>
<p>
	<strong>
		ii. Whenever a transaction T issues a read_item(X) operation, the
		following check is performed:
	</strong>
</p>
<p>
	a. If write_TS(X) &gt; TS(T), then abort and roll back T and reject the
	operation. This should be done because some younger transaction with
	timestamp greater than TS(T)-and hence after T in the timestamp
	ordering-has already written the value of item X before T had a chance to
	read X.
</p>
<p>
	b. If write_TS(X) &#8804; TS(T), then execute the read_item(X) operation of
	T and set read_TS(X) to the larger of TS(T) and the current read_TS(X).
</p>
<p>
	Whenever the basic TO algorithm detects two conflicting operations that
	occur in the incorrect order, it rejects the later of the two operations by
	aborting the transaction that issued it. The schedules produced by basic TO
	are hence guaranteed to be <strong>conflict serializable</strong>.
</p>
<p>
	<strong>10.2.2 </strong>
	<strong>Strict Timestamp Ordering (TO).</strong>
</p>
<p>
	A variation of basic TO called strict TO ensures that the schedules are
	both strict (for easy recoverability) and (conflict) serializable. In this
	variation, a transaction T issues a read_item(X) or write_item(X) such that
	TS(T) &gt; write_TS(X) has its read or write operation delayed until the
	transaction T&#8242; that wrote the value of X (hence TS(T&#8242;) =
	write_TS(X)) has committed or aborted.
</p>
<p>
	To implement this algorithm, it is necessary to simulate the locking of an
	item X that has been written by transaction T&#8242; until T&#8242; is
	either committed or aborted. This algorithm does not cause deadlock, since
	T waits for T&#8242; only if TS(T) &gt; TS(T&#8242;).
</p>
<p>
	<strong>10.2.3 Thomas's Write Rule.</strong>
</p>
<p>
	A modification of the basic TO algorithm, known as Thomas's write rule,
	does not enforce conflict serializability, but it rejects fewer write
	operations by modifying the checks for the write_item(X) operation as
	follows:
</p>
<p>
	a. If read_TS(X) &gt; TS(T), then abort and roll back T and reject the
	operation.
</p>
<p>
	b. If write_TS(X) &gt; TS(T), then do not execute the write operation but
	continue processing. This is because some transaction with timestamp
	greater than TS(T)-and hence after T in the timestamp ordering-has already
	written the value of X. Thus, we must ignore the write_item(X) operation of
	T because it is already outdated and obsolete. Notice that any conflict
	arising from this situation would be detected by case (1).
</p>
<p>
	c. If neither the condition in part (1) nor the condition in part (2)
	occurs, then execute the write_item(X) operation of T and set write_TS(X)
	to TS(T).
</p>

			
			</div><br/>
			</div>

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	NOTE: Each Page Provides only 5 Questions & Answer<br/>Below Page NAVIGATION Links are Provided...<br/> All the Questions on Question 
	Bank Is SOLVED<br/>
    </div>


<center>
<div id="showPGE">
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/5CSE/DBMS/M5/AS_DBMS_M5_P1.html'">1</button>
  <button class="btn active" onclick="window.location.href='/AnswerScript/WP/5CSE/DBMS/M5/AS_DBMS_M5_P2.html'">2</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/5CSE/DBMS/M5/AS_DBMS_M5_P3.html'">3</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/5CSE/DBMS/M5/AS_DBMS_M5_P4.html'">4</button>

</div>
</center>

<br/><br/>
<!-- Answer Script -->

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	SUGGESTION: SHARE WITH ALL THE STUDENTS AND FRIENDS -ADMIN
    </div>


 <hr/>
 
 
 
 
    
    <!-- call out --->
	<div class="callout">
	  <div class="callout-header">Instagram :</div>
	  <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
	  <div class="callout-container" id="cooMSg">
	  <br/><br/><br/>
		<p id="coMSG" >Follow our Instagram Page: <br/><a href="https://www.instagram.com/futurevisionbie/">FutureVisionBIE</a><br/>
		<a href="https://www.instagram.com/futurevisionbie/">https://www.instagram.com/futurevisionbie/</a><br/><br/>
		Message: I'm Unable to Reply to all your Emails <br/>so, You can DM me on the Instagram Page & any other Queries.
		</p>

	  </div>
	</div>
 
 
 
 
 
 
 
 
 
<br/><br/>
</article>

<footer>Copyright By Future Vision BIE 2018-2019 </footer>

</div>
</div>
</div>
</body>
</html>