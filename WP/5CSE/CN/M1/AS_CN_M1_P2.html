<!DOCTYPE html>
<html>
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146647335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146647335-1');
</script>
<title> ANSWER SCRIPT - CN </title>
<meta name="google-site-verification" content="google0186c8ef8f3bf22a.html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- indexing -->
<meta name="description" content="17CS52 COMPUTER NETWORK - ANSWER SCRIPT ">

<meta name="keywords" content="Future Visiob BIE,hemanth raj,VTU,Question paper,previous year,17CS52,COMPUTER NETWORKS, SOLVED PAPER CNJ, CN SOLVED QB">

<link rel="icon" type="image/ico" href="/FutureVisionBIE/logo.png" />

<link rel="stylesheet" href="https://hemanthrajhemu.github.io/FutureVisionBIE/style.css"/>				
		
<!--<link rel="stylesheet" href="file:///E:/BE%20CS/5th%20Sem/17CS51%20-%20MANAGEMENT%20AND%20ENTREPRENEURSHIP%20FOR%20IT%20INDUSTRY/ME-IT%20QB/ME_CONV_HTML/ME_M2/ME_M2_STYLE.css"/>				
<link rel="stylesheet" href="file:///E:/BE%20CS/5th%20Sem/17CS51%20-%20MANAGEMENT%20AND%20ENTREPRENEURSHIP%20FOR%20IT%20INDUSTRY/ME-IT%20QB/ME_CONV_HTML/ME_M2/style.css"/>
-->
</head>
<body onload="myFunction1()" style="margin:0;" oncopy="return false" onselectstart="return false">
<script src="https://hemanthrajhemu.github.io/FutureVisionBIE/script.js"> </script>
<div id="loader"></div>
<div style="display:none;" id="myDiv" class="animate-bottom">
<div id="main">
<div class="container">
<!-- HEADER NAME WITH LOGO  -->
<header>
   <h1 class="FVBIE"><a href="https://hemanthrajhemu.github.io"><img src="/FutureVisionBIE/logo.png" alt="Future Vision BIE" style="float:left ;width:170px;height:140px;"></a>
   Future Vision BIE</h1><br/> <h1 class="FVBIE1">ONE STOP FOR ALL STUDY MATERIALS & LAB PROGRAMS</h1><br/>
   
</header>
<!-- TOP NAVIGATION TOOLS -->
<div class="topnav">
  
  <a class="openbtn" onclick="openNav()" style="font-family:courier; font-size:25px; text-align:center;">
	<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/menu.png" alt="E" style="width:38px;height:38px;"/>
	MENU
  </a>
  <a href="https://bit.ly/FVBIESHARE" style="float:right;" >
				<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/web.png" alt="Whatsapp Share" style="float:right; width:80px;height:40px;"/>
  </a>
  <a href="https://t.me/joinchat/AAAAAFTtp8kuvCHALxuMaQ" style="float:right;">Join Telegram, to get Instant Updates</a>

</div>
<!--  NAVIGATION TOOLS -->
<div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">
		<img src="https://hemanthrajhemu.github.io/FutureVisionBIE/cancel-64.png" alt="X" style="width:64px;height:64px;"/>
	</a><br/>
  
<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/disclaimer.html">Disclaimer</a>
    
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/JavaHtml/java.html">4th sem <br/>Java-DAA Programs</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE">5th sem CSE</br>Text Book</br>Programs</br></a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/M&T.html">17CS51 -<br/> MANAGEMENT AND ENTREPRENEURSHIP FOR IT INDUSTRY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/CN.html"> 17CS52 -<br/> COMPUTER NETWORKS</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/DBMS.html"> 17CS53 -<br/> DATABASE MANAGEMENT SYSTEM</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/ATC.html">17CS54 -<br/> AUTOMATA THEORY AND COMPUTABILITY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AVD_JAVA.html">17CS553  -<br/> ADVANCED JAVA AND J2EE</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AI.html">17CS562 -<br/> ARTIFICIAL INTELLIGENCE</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/LAB_CN.html">17CSL57 -<br/> COMPUTER NETWORK LABORATORY</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/LAB_DBMS.html">17CSL58 -<br/> DBMS LABORATORY WITH MINI PROJECT</a>
    <a href="https://hemanthrajhemu.github.io/FutureVisionBIE/WP/5CSE/AVD_ALGO.html">17CS554 - ADVANCED ALGORITHMS </a>
    
	</br></br></br></br></br></br></br></br></br></br></br></br>
	
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/contact.html">CONTACT</a>
	<a href="https://hemanthrajhemu.github.io/FutureVisionBIE/">HOME</a></br></br></br></br>
</div>
<!-- CENTER PATH FOR INFO  -->
<article>



	<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	  <strong>NOTE!</strong>
	  Click on MENU to Browse between Subjects...
	</div>

 <div class="desp" style="text-align:center;"> 
 <h1>
 17CS52 - COMPUTER NETWORKS
 </h1><h1>
 </h1><h1>Answer Script for Module 1
 </h1><h1>Solved Previous Year Question Paper
 </h1><h1>CBCS SCHEME</h1>
 
<br/>
</p></div>




 <div class="desp" style="text-align:center;"> 
 <h1>
 COMPUTER NETWORKS
 </h1><h1>
 </h1><h1>[As per Choice Based Credit System (CBCS) scheme]
 </h1><h1>(Effective from the academic year 2019 -2020)
 </h1><h1>SEMESTER - V<br/>
 </h1><h1>Subject Code 17CS52 			       	   <br/>     IA Marks 40
 </h1><h1>Number of Lecture Hours/Week 04 	<br/>	Exam Marks 60</h1>
<br/>
</p></div>

<hr/>

<!-- CONTENT AFTER LINK  -->

 <div class="desp" style="text-align: justify;"> 
 <h1>
 These Questions are being framed for helping the students in the "FINAL Exams" Only 
 (Remember for Internals the Question Paper is set by your respective teachers). 
 Questions may be repeated, just to show students how VTU can frame Questions.
<br/></h1>
<p style="color:green; font-family:courier; font-size:25px; text-align:right;">
-	ADMIN</p>
<br/>
</h1>
</div>
<br/>
<br/>

 <div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
 CLICK ON THE QUESTIONS TO VIEW ANSWER<br/></h1>
</div>
 <br/>
<!-- trying now--->
  

<!-- Answer Script -->

			<div class="ansCover">
			<div class="QAS"><a onclick="show('ANScript1')">Question 6<h1>Illustrate the basic operation of SMTP with an example. (4-Marks) (2c) </h1>(Dec.2017/Jan.2018)</a></div>
			<div class="ansclass" id="ANScript1">
				
				<p>
	SMTP is the principal application-layer protocol for Internet electronic
	mail. It uses the reliable data transfer service of TCP to transfer mail
	from the sender's mail server to the recipient's mail server. As with most
	application-layer protocols, SMTP has two sides: a client side, which
	executes on the sender's mail server, and a server side, which executes on
	the recipient's mail server. Both the client and server sides of SMTP run
	on every mail server. When a mail server sends mail to other mail servers,
	it acts as an SMTP client. When a mail server receives mail from other mail
	servers, it acts as an SMTP server
</p>
<p>
	SMTP, defined in RFC 5321, is at the heart of Internet electronic mail. As
	mentioned above, SMTP transfers messages from senders' mail servers to the
	recipients' mail servers. SMTP is much older than HTTP. (The original SMTP
	RFC dates back to 1982, and SMTP was around long before that.) Although
	SMTP has numerous wonderful qualities, as evidenced by its ubiquity in the
	Internet, it is nevertheless a legacy technology that possesses certain
	archaic characteristics.
</p>
<p>
	For example, it restricts the body (not just the headers) of all mail
	messages to simple 7-bit ASCII. This restriction made sense in the early
	1980s when transmission capacity was scarce and no one was e-mailing large
	attachments or large image, audio, or video files. But today, in the
	multimedia era, the 7-bit ASCII restriction is a bit of a pain-it requires
	binary multimedia data to be encoded to ASCII before being sent over SMTP;
	and it requires the corresponding ASCII message to be decoded back to
	binary after SMTP transport. Recall from Section 2.2 that HTTP does not
	require multimedia data to be ASCII encoded before transfer.
</p>
<p>
	To illustrate the basic operation of SMTP, let's walk through a common
	scenario. Suppose Alice wants to send Bob a simple ASCII message.
</p>
<p>
	1. Alice invokes her user agent for e-mail, provides Bob's e-mail address
	(for example, bob@someschool.edu), composes a message, and instructs the
	user agent to send the message.
</p>
<p>
	2. Alice's user agent sends the message to her mail server, where it is
	placed in a message queue.
</p>
<p>
	3. The client side of SMTP, running on Alice's mail server, sees the
	message in the message queue. It opens a TCP connection to an SMTP server,
	running on Bob's mail server.
</p>
<p>
	4. After some initial SMTP handshaking, the SMTP client sends Alice's
	message into the TCP connection.
</p>
<p>
	5. At Bob's mail server, the server side of SMTP receives the message.
	Bob's mail server then places the message in Bob's mailbox.
</p>
<p>
	6. Bob invokes his user agent to read the message at his convenience.
</p>
<p align="center">
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/6.1.png" 
alt="Loading Image" class="resIMG"/><br/>
	Fig 6.1: Alice sends a message to Bob</center>
</p>
<p>
	It is important to observe that SMTP does not normally use intermediate
	mail servers for sending mail, even when the two mail servers are located
	at opposite ends of the world. If Alice's server is in Hong Kong and Bob's
	server is in St. Louis, the TCP connection is a direct connection between
	the Hong Kong and St. Louis servers. In particular, if Bob's mail server is
	down, the message remains in Alice's mail server and waits for a new
	attempt-the message does not get placed in some intermediate mail server.
</p>
<p>
	Let's now take a closer look at how SMTP transfers a message from a sending
	mail server to a receiving mail server. We will see that the SMTP protocol
	has many similarities with protocols that are used for face-to-face human
	interaction. First, the client SMTP (running on the sending mail server
	host) has TCP establish a connection to port 25 at the server SMTP (running
	on the receiving mail server host). If the server is down, the client tries
	again later. Once this connection is established, the server and client
	perform some application-layer handshaking-just as humans often introduce
	themselves before transferring information from one to another, SMTP
	clients and servers introduce themselves before transferring information.
	During this SMTP handshaking phase, the SMTP client indicates the e-mail
	address of the sender (the person who generated the message) and the e-mail
	address of the recipient. Once the SMTP client and server have introduced
	themselves to each other, the client sends the message. SMTP can count on
	the reliable data transfer service of TCP to get the message to the server
	without errors. The client then repeats this process over the same TCP
	connection if it has other messages to send to the server; otherwise, it
	instructs TCP to close the connection.
</p>

				
			</div><br/>
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript2')">Question 7<h1>What are the different types of transport services provided by the internet? (8-Marks) (1a)</h1>(June/July 2018)</a></div>
			<div class="ansclass" id="ANScript2">
				
				<p>
	The Internet (and, more generally, TCP/IP networks) makes two transport
	protocols available to applications, UDP and TCP. When you (as an
	application developer) create a new network application for the Internet,
	one of the first decisions you have to make is whether to use UDP or TCP.
	Each of these protocols offers a different set of services to the invoking
	applications. The above Figure shows the service requirements for some
	selected applications.
</p>
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/7.1.png" 
alt="Requirements of selected network applications" class="resIMG"/><br/></center>
<p align="center">
	Fig 7.1: Requirements of selected network applications
</p>
<p>
	<strong>7.1 TCP Services </strong>
</p>
<p>
	The TCP service model includes a connection-oriented service and a reliable
	data transfer service. When an application invokes TCP as its transport
	protocol, the application receives both of these services from TCP.
</p>
<p>
	<strong>7.1.1 Connection-oriented service:</strong>
	TCP has the client and server exchange transport layer control information
	with each other before the application-level messages begin to flow. This
	so-called handshaking procedure alerts the client and server, allowing them
	to prepare for an onslaught of packets. After the handshaking phase, a TCP
	connection is said to exist between the sockets of the two processes. The
	connection is a full-duplex connection in that the two processes can send
	messages to each other over the connection at the same time. When the
	application finishes sending messages, it must tear down the connection
</p>
<p>
	<strong>7.1.2 Reliable data transfer service:</strong>
	The communicating processes can rely on TCP to deliver all data sent
	without error and in the proper order. When one side of the application
	passes a stream of bytes into a socket, it can count on TCP to deliver the
	same stream of bytes to the receiving socket, with no missing or duplicate
	bytes.
</p>
<p>
	TCP also includes a congestion-control mechanism, a service for the general
	welfare of the Internet rather than for the direct benefit of the
	communicating processes. The TCP congestion-control mechanism throttles a
	sending process (client or server) when the network is congested between
	sender and receiver. As we will see in Chapter 3, TCP congestion control
	also attempts to limit each TCP connection to its fair share of network
	bandwidth.
</p>
<p>
	<strong>7.2 UDP Services </strong>
</p>
<p>
	UDP is a no-frills, lightweight transport protocol, providing minimal
	services. UDP is connectionless, so there is no handshaking before the two
	processes start to communicate. UDP provides an unreliable data transfer
	service-that is, when a process sends a message into a UDP socket, UDP
	provides no guarantee that the message will ever reach the receiving
	process. Furthermore, messages that do arrive at the receiving process may
	arrive out of order.
</p>
<p>
	UDP does not include a congestion-control mechanism, so the sending side of
	UDP can pump data into the layer below (the network layer) at any rate it
	pleases. (Note, however, that the actual end-to-end throughput may be less
	than this rate due to the limited transmission capacity of intervening
	links or due to congestion).
</p>

				
			</div><br/>
			
<!-- Answer Script -->
			<div class="QAS"><a onclick="show('ANScript3')">Question 8<h1>Compose logical note on proxy-server with suitable diagram. (8-Marks) (1b)</h1>(June/July 2018)</a></div>
			<div class="ansclass" id="ANScript3">
			<br/><br/>
				Refer 7<sup>th</sup> Question & Answer OR <a href="/AnswerScript/WP/5CSE/CN/M1/AS_CN_M1_P2.html">CLICK HERE</a>
			</div><br/>
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript4')">Question 9<h1>Discuss how files are distributed in peer-to-peer application. (8-Marks) (2a)</h1>(June/July 2018)</a></div>
			<div class="ansclass" id="ANScript4">
				
				<p>
	We begin our foray into P2P by considering a very natural application,
	namely, distributing a large file from a single server to a large number of
	hosts (called peers). The file might be a new version of the Linux
	operating system, a software patch for an existing operating system or
	application, an MP3 music file, or an MPEG video file. In client-server
	file distribution, the server must send a copy of the file to each of the
	peers-placing an enormous burden on the server and consuming a large amount
	of server bandwidth.
</p>
<p>
	In P2P file distribution, each peer can redistribute any portion of the
	file it has received to any other peers, thereby assisting the server in
	the distribution process. As of 2012, the most popular P2P file
	distribution protocol is BitTorrent. Originally developed by Bram Cohen,
	there are now many different independent BitTorrent clients conforming to
	the BitTorrent protocol, just as there are a number of Web browser clients
	that conform to the HTTP protocol.
</p>
<p>
	In this subsection, we first examine the selfscalability of P2P
	architectures in the context of file distribution. We then describe
	BitTorrent in some detail, highlighting its most important characteristics
	and features.
</p>
<p>
	<strong>Scalability of P2P Architectures</strong>
</p>
<p>
	To compare client-server architectures with peer-to-peer architectures, and
	illustrate the inherent self-scalability of P2P, we now consider a simple
	quantitative model for distributing a file to a fixed set of peers for both
	architecture types. As shown in the below Figure, the server and the peers
	are connected to the Internet with access links. Denote the upload rate of
	the server's access link by u<sub>s</sub> , the upload rate of the ith
	peer's access link by u<sub>i</sub> , and the download rate of the ith
	peer's access link by d<sub>i</sub> . Also denote the size of the file to
	be distributed (in bits) by F and the number of peers that want to obtain
</p>
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/9.1.png" 
alt="Loading Image" class="resIMG"/><br/></center>
<p align="center">
	Fig: An illustrative file distribution problem
</p>
<p>
	The <strong>distribution time</strong> is the time it takes to get a copy
	of the file to all N peers. In our analysis of the distribution time below,
	for both client-server and P2P architectures, we make the simplifying
	assumption that the Internet core has abundant bandwidth, implying that all
	of the bottlenecks are in access networks. We also suppose that the server
	and clients are not participating in any other network applications, so
	that all of their upload and download access bandwidth can be fully devoted
	to distributing this file.
</p>
<p>
	Let's first determine the distribution time for the client-server
	architecture, which we denote by D<sub>cs</sub>. In the client-server
	architecture, none of the peers aids in distributing the file. We make the
	following observations:
</p>
<p>
	<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/9.2.png" 
alt="Loading Image" class="resIMG"/><br/></center>
</p>
<p>
	Let's now go through a similar analysis for the P2P architecture, where
	each peer can assist the server in distributing the file. In particular,
	when a peer receives some file data, it can use its own upload capacity to
	redistribute the data to other peers. Calculating the distribution time for
	the P2P architecture is somewhat more complicated than for the
	client-server architecture, since the distribution time depends on how each
	peer distributes portions of the file to the other peers. Nevertheless, a
	simple expression for the minimal distribution time can be obtained [Kumar
	2006]. To this end, we first make the following observations:
</p>
<p>
	i. At the beginning of the distribution, only the server has the file. To
	get this file into the community of peers, the server must send each bit of
	the file at least once into its access link. Thus, the minimum distribution
	time is at least F/u<sub>s</sub>. (Unlike the client-server scheme, a bit
	sent once by the server may not have to be sent by the server again, as the
	peers may redistribute the bit among themselves.)
</p>
<p>
	ii. As with the client-server architecture, the peer with the lowest
download rate cannot obtain all F bits of the file in less than F/d<sub>min</sub> seconds. Thus the minimum distribution time is at least F/d	<sub>min</sub>.
</p>
<p>
	iii. Finally, observe that the total upload capacity of the system as a
	whole is equal to the upload rate of the server plus the upload rates of
	each of the individual peers, that is, u<sub>total</sub> = u<sub>s</sub> +
	u<sub>1</sub> + &#8230; + u<sub>N</sub>. The system must deliver (upload) F
	bits to each of the N peers, thus delivering a total of NF bits. This
	cannot be done at a rate faster than u<sub>total</sub>. Thus, the minimum
	distribution time is also at least NF/(u<sub>s</sub> + u<sub>1</sub> +
	&#8230; + u<sub>N</sub>)
</p>
<p>
	Putting these three observations together, we obtain the minimum
	distribution time for P2P, denoted by D<sub>P2P</sub>.
</p>
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/9.3.png" 
alt="Loading Image" class="resIMG"/><br/></center>
<p>
	<strong>BitTorrent </strong>
</p>
<p>
	BitTorrent is a popular P2P protocol for file distribution [Chao 2011]. In
	BitTorrent lingo, the collection of all peers participating in the
	distribution of a particular file is called a torrent. Peers in a torrent
	download equal-size chunks of the file from one another, with a typical
	chunk size of 256 KBytes. When a peer first joins a torrent, it has no
	chunks. Over time it accumulates more and more chunks. While it downloads
	chunks it also uploads chunks to other peers. Once a peer has acquired the
	entire file, it may (selfishly) leave the torrent, or (altruistically)
	remain in the torrent and continue to upload chunks to other peers. Also,
	any peer may leave the torrent at any time with only a subset of chunks,
	and later rejoin the torrent.
</p>
<p>
	Let's now take a closer look at how BitTorrent operates. Since BitTorrent
	is a rather complicated protocol and system, we'll only describe its most
	important mechanisms, sweeping some of the details under the rug; this will
	allow us to see the forest through the trees. Each torrent has an
	infrastructure node called a tracker. When a peer joins a torrent, it
	registers itself with the tracker and periodically informs the tracker that
	it is still in the torrent. In this manner, the tracker keeps track of the
	peers that are participating in the torrent. A given torrent may have fewer
	than ten or more than a thousand peers participating at any instant of
	time.
</p>
<p>
	As shown in the below Figure, when a new peer, Alice, joins the torrent,
	the tracker randomly selects a subset of peers (for concreteness, say 50)
	from the set of participating peers, and sends the IP addresses of these 50
	peers to Alice. Possessing this list of peers, Alice attempts to establish
	concurrent TCP connections with all the peers on this list. Let's call all
	the peers with which Alice succeeds in establishing a TCP connection
	"neighboring peers." As time evolves, some of these peers may leave and
	other peers (outside the initial 50) may attempt to establish TCP
	connections with Alice. So a peer's neighboring peers will fluctuate over
	time.
</p>
<p>
	At any given time, each peer will have a subset of chunks from the file,
	with different peers having different subsets. Periodically, Alice will ask
	each of her neighboring peers (over the TCP connections) for the list of
	the chunks they have. If Alice has L different neighbors, she will obtain L
	lists of chunks. With this knowledge, Alice will issue requests (again over
	the TCP connections) for chunks she currently does not have.
</p>
<p>
	So at any given instant of time, Alice will have a subset of chunks and
	will know which chunks her neighbors have. With this information, Alice
	will have two important decisions to make. First, which chunks should she
	request first from her neighbors? And second, to which of her neighbors
	should she send requested chunks? In deciding which chunks to request,
	Alice uses a technique called rarest first. The idea is to determine, from
	among the chunks she does not have, the chunks that are the rarest among
	her neighbors (that is, the chunks that have the fewest repeated copies
	among her neighbors) and then request those rarest chunks first. In this
	manner, the rarest chunks get more quickly redistributed, aiming to
	(roughly) equalize the numbers of copies of each chunk
</p>
<center><img src="https://hemanthrajhemu.github.io/AnswerScript/WP/5CSE/CN/M1/CN_M1/9.4.png" 
alt="Loading Image" class="resIMG"/><br/></center>
<p align="center">
	Fig: File distribution with BitTorrent.
</p>
<p>
	To determine which requests she responds to, BitTorrent uses a clever
	trading algorithm. The basic idea is that Alice gives priority to the
	neighbors that are currently supplying her data at the highest rate.
	Specifically, for each of her neighbors, Alice continually measures the
	rate at which she receives bits and determines the four peers that are
	feeding her bits at the highest rate. She then reciprocates by sending
	chunks to these same four peers. Every 10 seconds, she recalculates the
	rates and possibly modifies the set of four peers. In BitTorrent lingo,
	these four peers are said to be unchoked. Importantly, every 30 seconds,
	she also picks one additional neighbor at random and sends it chunks. Let's
	call the randomly chosen peer Bob. In BitTorrent lingo, Bob is said to be
	optimistically unchoked. Because Alice is sending data to Bob, she may
	become one of Bob's top four uploaders, in which case Bob would start to
	send data to Alice. If the rate at which Bob sends data to Alice is high
	enough, Bob could then, in turn, become one of Alice's top four uploaders.
	In other words, every 30 seconds, Alice will randomly choose a new trading
	partner and initiate trading with that partner. If the two peers are
	satisfied with the trading, they will put each other in their top four
	lists and continue trading with each other until one of the peers finds a
	better partner. The effect is that peers capable of uploading at compatible
	rates tend to find each other. The random neighbor selection also allows
	new peers to get chunks, so that they can have something to trade. All
	other neighboring peers besides these five peers (four "top" peers and one
	probing peer) are "choked," that is, they do not receive any chunks from
	Alice. BitTorrent has a number of interesting mechanisms that are not
	discussed here, including pieces (mini-chunks), pipelining, random first
	selection, endgame mode, and anti-snubbing [Cohen 2003].
</p>

				
				
			</div><br/>
<!-- Answer Script -->

			<div class="QAS"><a onclick="show('ANScript5')">Question 10<h1>Design network application using socket programming with UDP. (8-Marks) (2b)</h1>(June/July 2018)</a></div>
			<div class="ansclass" id="ANScript5">
			<br/><br/>
				Refer 4<sup>th</sup> Question & Answer OR <a href="/AnswerScript/WP/5CSE/CN/M1/AS_CN_M1_P1.html">CLICK HERE</a>
			<br/><br/>
			</div><br/>
			</div>

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	NOTE: Each Page Provides only 5 Questions & Answer<br/>Below Page NAVIGATION Links are Provided...<br/> All the Questions on Question 
	Bank Is SOLVED<br/>
    </div>


<center>
<div id="showPGE">
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/5CSE/CN/M1/AS_CN_M1_P1.html'">1</button>
  <button class="btn active" onclick="window.location.href='/AnswerScript/WP/5CSE/CN/M1/AS_CN_M1_P2.html'">2</button>
  <button class="btn" onclick="window.location.href='/AnswerScript/WP/5CSE/CN/M1/AS_CN_M1_P3.html'">3</button>
  
  
</div>
</center>
<br/><br/>
<!-- Answer Script -->

<div class="alertA1">
	  <span class="closebtnA1" onclick="this.parentElement.style.display='none';">&times;</span> 
	SUGGESTION: SHARE WITH ALL THE STUDENTS AND FRIENDS -ADMIN
    </div>


 <hr/>
 
<br/><br/>
</article>

<footer>Copyright By Future Vision BIE 2018-2019 </footer>

</div>
</div>
</div>
</body>
</html>